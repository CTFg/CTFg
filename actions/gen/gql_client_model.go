// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
type BooleanComparisonExp struct {
	Eq     *bool  `json:"_eq"`
	Gt     *bool  `json:"_gt"`
	Gte    *bool  `json:"_gte"`
	In     []bool `json:"_in"`
	IsNull *bool  `json:"_is_null"`
	Lt     *bool  `json:"_lt"`
	Lte    *bool  `json:"_lte"`
	Neq    *bool  `json:"_neq"`
	Nin    []bool `json:"_nin"`
}

type EchoOutput struct {
	Message string `json:"message"`
}

// Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
type IntComparisonExp struct {
	Eq     *int64  `json:"_eq"`
	Gt     *int64  `json:"_gt"`
	Gte    *int64  `json:"_gte"`
	In     []int64 `json:"_in"`
	IsNull *bool   `json:"_is_null"`
	Lt     *int64  `json:"_lt"`
	Lte    *int64  `json:"_lte"`
	Neq    *int64  `json:"_neq"`
	Nin    []int64 `json:"_nin"`
}

type RegisterOutput struct {
	ID    int64  `json:"id"`
	Token string `json:"token"`
}

// Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
type StringComparisonExp struct {
	Eq  *string `json:"_eq"`
	Gt  *string `json:"_gt"`
	Gte *string `json:"_gte"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike"`
	In    []string `json:"_in"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex"`
	IsNull *bool   `json:"_is_null"`
	// does the column match the given pattern
	Like *string `json:"_like"`
	Lt   *string `json:"_lt"`
	Lte  *string `json:"_lte"`
	Neq  *string `json:"_neq"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike"`
	Nin    []string `json:"_nin"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar"`
}

type SubmitAttemptMutationOutput struct {
	ID int64 `json:"id"`
}

type UnlockMutationOutput struct {
	ID int64 `json:"id"`
	// An object relationship
	Unlock *Unlocks `json:"unlock"`
}

// columns and relationships of "awards"
type Awards struct {
	Category     *string    `json:"category"`
	Date         *time.Time `json:"date"`
	Description  *string    `json:"description"`
	Icon         *string    `json:"icon"`
	ID           int64      `json:"id"`
	Name         *string    `json:"name"`
	Requirements *string    `json:"requirements"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Type   *string `json:"type"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
	Value  *int64 `json:"value"`
}

// aggregated selection of "awards"
type AwardsAggregate struct {
	Aggregate *AwardsAggregateFields `json:"aggregate"`
	Nodes     []*Awards              `json:"nodes"`
}

// aggregate fields of "awards"
type AwardsAggregateFields struct {
	Avg        *AwardsAvgFields        `json:"avg"`
	Count      int64                   `json:"count"`
	Max        *AwardsMaxFields        `json:"max"`
	Min        *AwardsMinFields        `json:"min"`
	Stddev     *AwardsStddevFields     `json:"stddev"`
	StddevPop  *AwardsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *AwardsStddevSampFields `json:"stddev_samp"`
	Sum        *AwardsSumFields        `json:"sum"`
	VarPop     *AwardsVarPopFields     `json:"var_pop"`
	VarSamp    *AwardsVarSampFields    `json:"var_samp"`
	Variance   *AwardsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "awards"
type AwardsAggregateOrderBy struct {
	Avg        *AwardsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                 `json:"count"`
	Max        *AwardsMaxOrderBy        `json:"max"`
	Min        *AwardsMinOrderBy        `json:"min"`
	Stddev     *AwardsStddevOrderBy     `json:"stddev"`
	StddevPop  *AwardsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *AwardsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *AwardsSumOrderBy        `json:"sum"`
	VarPop     *AwardsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *AwardsVarSampOrderBy    `json:"var_samp"`
	Variance   *AwardsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "awards"
type AwardsArrRelInsertInput struct {
	Data []*AwardsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *AwardsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type AwardsAvgFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by avg() on columns of table "awards"
type AwardsAvgOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// Boolean expression to filter rows from the table "awards". All fields are combined with a logical 'AND'.
type AwardsBoolExp struct {
	And          []*AwardsBoolExp        `json:"_and"`
	Not          *AwardsBoolExp          `json:"_not"`
	Or           []*AwardsBoolExp        `json:"_or"`
	Category     *StringComparisonExp    `json:"category"`
	Date         *TimestampComparisonExp `json:"date"`
	Description  *StringComparisonExp    `json:"description"`
	Icon         *StringComparisonExp    `json:"icon"`
	ID           *IntComparisonExp       `json:"id"`
	Name         *StringComparisonExp    `json:"name"`
	Requirements *JSONComparisonExp      `json:"requirements"`
	Team         *TeamsBoolExp           `json:"team"`
	TeamID       *IntComparisonExp       `json:"team_id"`
	Type         *StringComparisonExp    `json:"type"`
	User         *UsersBoolExp           `json:"user"`
	UserID       *IntComparisonExp       `json:"user_id"`
	Value        *IntComparisonExp       `json:"value"`
}

// input type for incrementing numeric columns in table "awards"
type AwardsIncInput struct {
	ID     *int64 `json:"id"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
	Value  *int64 `json:"value"`
}

// input type for inserting data into table "awards"
type AwardsInsertInput struct {
	Category     *string                 `json:"category"`
	Date         *time.Time              `json:"date"`
	Description  *string                 `json:"description"`
	Icon         *string                 `json:"icon"`
	ID           *int64                  `json:"id"`
	Name         *string                 `json:"name"`
	Requirements *string                 `json:"requirements"`
	Team         *TeamsObjRelInsertInput `json:"team"`
	TeamID       *int64                  `json:"team_id"`
	Type         *string                 `json:"type"`
	User         *UsersObjRelInsertInput `json:"user"`
	UserID       *int64                  `json:"user_id"`
	Value        *int64                  `json:"value"`
}

// aggregate max on columns
type AwardsMaxFields struct {
	Category    *string    `json:"category"`
	Date        *time.Time `json:"date"`
	Description *string    `json:"description"`
	Icon        *string    `json:"icon"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
	Value       *int64     `json:"value"`
}

// order by max() on columns of table "awards"
type AwardsMaxOrderBy struct {
	Category    *OrderBy `json:"category"`
	Date        *OrderBy `json:"date"`
	Description *OrderBy `json:"description"`
	Icon        *OrderBy `json:"icon"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
	Value       *OrderBy `json:"value"`
}

// aggregate min on columns
type AwardsMinFields struct {
	Category    *string    `json:"category"`
	Date        *time.Time `json:"date"`
	Description *string    `json:"description"`
	Icon        *string    `json:"icon"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
	Value       *int64     `json:"value"`
}

// order by min() on columns of table "awards"
type AwardsMinOrderBy struct {
	Category    *OrderBy `json:"category"`
	Date        *OrderBy `json:"date"`
	Description *OrderBy `json:"description"`
	Icon        *OrderBy `json:"icon"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
	Value       *OrderBy `json:"value"`
}

// response of any mutation on the table "awards"
type AwardsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Awards `json:"returning"`
}

// on conflict condition type for table "awards"
type AwardsOnConflict struct {
	Constraint    AwardsConstraint     `json:"constraint"`
	UpdateColumns []AwardsUpdateColumn `json:"update_columns"`
	Where         *AwardsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "awards".
type AwardsOrderBy struct {
	Category     *OrderBy      `json:"category"`
	Date         *OrderBy      `json:"date"`
	Description  *OrderBy      `json:"description"`
	Icon         *OrderBy      `json:"icon"`
	ID           *OrderBy      `json:"id"`
	Name         *OrderBy      `json:"name"`
	Requirements *OrderBy      `json:"requirements"`
	Team         *TeamsOrderBy `json:"team"`
	TeamID       *OrderBy      `json:"team_id"`
	Type         *OrderBy      `json:"type"`
	User         *UsersOrderBy `json:"user"`
	UserID       *OrderBy      `json:"user_id"`
	Value        *OrderBy      `json:"value"`
}

// primary key columns input for table: awards
type AwardsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "awards"
type AwardsSetInput struct {
	Category     *string    `json:"category"`
	Date         *time.Time `json:"date"`
	Description  *string    `json:"description"`
	Icon         *string    `json:"icon"`
	ID           *int64     `json:"id"`
	Name         *string    `json:"name"`
	Requirements *string    `json:"requirements"`
	TeamID       *int64     `json:"team_id"`
	Type         *string    `json:"type"`
	UserID       *int64     `json:"user_id"`
	Value        *int64     `json:"value"`
}

// aggregate stddev on columns
type AwardsStddevFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by stddev() on columns of table "awards"
type AwardsStddevOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate stddev_pop on columns
type AwardsStddevPopFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by stddev_pop() on columns of table "awards"
type AwardsStddevPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate stddev_samp on columns
type AwardsStddevSampFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by stddev_samp() on columns of table "awards"
type AwardsStddevSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate sum on columns
type AwardsSumFields struct {
	ID     *int64 `json:"id"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
	Value  *int64 `json:"value"`
}

// order by sum() on columns of table "awards"
type AwardsSumOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate var_pop on columns
type AwardsVarPopFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by var_pop() on columns of table "awards"
type AwardsVarPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate var_samp on columns
type AwardsVarSampFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by var_samp() on columns of table "awards"
type AwardsVarSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// aggregate variance on columns
type AwardsVarianceFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
	Value  *float64 `json:"value"`
}

// order by variance() on columns of table "awards"
type AwardsVarianceOrderBy struct {
	ID     *OrderBy `json:"id"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
	Value  *OrderBy `json:"value"`
}

// Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
type BigintComparisonExp struct {
	Eq     *int64  `json:"_eq"`
	Gt     *int64  `json:"_gt"`
	Gte    *int64  `json:"_gte"`
	In     []int64 `json:"_in"`
	IsNull *bool   `json:"_is_null"`
	Lt     *int64  `json:"_lt"`
	Lte    *int64  `json:"_lte"`
	Neq    *int64  `json:"_neq"`
	Nin    []int64 `json:"_nin"`
}

// columns and relationships of "challenges"
type Challenges struct {
	Category *string `json:"category"`
	// An array relationship
	Comments []*Comments `json:"comments"`
	// An aggregate relationship
	CommentsAggregate *CommentsAggregate `json:"comments_aggregate"`
	Description       *string            `json:"description"`
	// An array relationship
	Files []*Files `json:"files"`
	// An aggregate relationship
	FilesAggregate *FilesAggregate `json:"files_aggregate"`
	// An array relationship
	Flags []*Flags `json:"flags"`
	// An aggregate relationship
	FlagsAggregate *FlagsAggregate `json:"flags_aggregate"`
	// An array relationship
	Hints []*Hints `json:"hints"`
	// An aggregate relationship
	HintsAggregate *HintsAggregate `json:"hints_aggregate"`
	ID             int64           `json:"id"`
	MaxAttempts    *int64          `json:"max_attempts"`
	Name           *string         `json:"name"`
	Requirements   *string         `json:"requirements"`
	// A computed field, executes function "challenges_solved"
	Solved *bool `json:"solved"`
	// An array relationship
	Solves []*Solves `json:"solves"`
	// An aggregate relationship
	SolvesAggregate *SolvesAggregate `json:"solves_aggregate"`
	State           string           `json:"state"`
	// An array relationship
	Submissions []*Submissions `json:"submissions"`
	// An aggregate relationship
	SubmissionsAggregate *SubmissionsAggregate `json:"submissions_aggregate"`
	// An array relationship
	Tags []*Tags `json:"tags"`
	// An aggregate relationship
	TagsAggregate *TagsAggregate `json:"tags_aggregate"`
	Type          *string        `json:"type"`
	Value         *int64         `json:"value"`
}

// aggregated selection of "challenges"
type ChallengesAggregate struct {
	Aggregate *ChallengesAggregateFields `json:"aggregate"`
	Nodes     []*Challenges              `json:"nodes"`
}

// aggregate fields of "challenges"
type ChallengesAggregateFields struct {
	Avg        *ChallengesAvgFields        `json:"avg"`
	Count      int64                       `json:"count"`
	Max        *ChallengesMaxFields        `json:"max"`
	Min        *ChallengesMinFields        `json:"min"`
	Stddev     *ChallengesStddevFields     `json:"stddev"`
	StddevPop  *ChallengesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ChallengesStddevSampFields `json:"stddev_samp"`
	Sum        *ChallengesSumFields        `json:"sum"`
	VarPop     *ChallengesVarPopFields     `json:"var_pop"`
	VarSamp    *ChallengesVarSampFields    `json:"var_samp"`
	Variance   *ChallengesVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type ChallengesAvgFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// Boolean expression to filter rows from the table "challenges". All fields are combined with a logical 'AND'.
type ChallengesBoolExp struct {
	And          []*ChallengesBoolExp `json:"_and"`
	Not          *ChallengesBoolExp   `json:"_not"`
	Or           []*ChallengesBoolExp `json:"_or"`
	Category     *StringComparisonExp `json:"category"`
	Comments     *CommentsBoolExp     `json:"comments"`
	Description  *StringComparisonExp `json:"description"`
	Files        *FilesBoolExp        `json:"files"`
	Flags        *FlagsBoolExp        `json:"flags"`
	Hints        *HintsBoolExp        `json:"hints"`
	ID           *IntComparisonExp    `json:"id"`
	MaxAttempts  *IntComparisonExp    `json:"max_attempts"`
	Name         *StringComparisonExp `json:"name"`
	Requirements *JSONComparisonExp   `json:"requirements"`
	Solves       *SolvesBoolExp       `json:"solves"`
	State        *StringComparisonExp `json:"state"`
	Submissions  *SubmissionsBoolExp  `json:"submissions"`
	Tags         *TagsBoolExp         `json:"tags"`
	Type         *StringComparisonExp `json:"type"`
	Value        *IntComparisonExp    `json:"value"`
}

// input type for incrementing numeric columns in table "challenges"
type ChallengesIncInput struct {
	ID          *int64 `json:"id"`
	MaxAttempts *int64 `json:"max_attempts"`
	Value       *int64 `json:"value"`
}

// input type for inserting data into table "challenges"
type ChallengesInsertInput struct {
	Category     *string                       `json:"category"`
	Comments     *CommentsArrRelInsertInput    `json:"comments"`
	Description  *string                       `json:"description"`
	Files        *FilesArrRelInsertInput       `json:"files"`
	Flags        *FlagsArrRelInsertInput       `json:"flags"`
	Hints        *HintsArrRelInsertInput       `json:"hints"`
	ID           *int64                        `json:"id"`
	MaxAttempts  *int64                        `json:"max_attempts"`
	Name         *string                       `json:"name"`
	Requirements *string                       `json:"requirements"`
	Solves       *SolvesArrRelInsertInput      `json:"solves"`
	State        *string                       `json:"state"`
	Submissions  *SubmissionsArrRelInsertInput `json:"submissions"`
	Tags         *TagsArrRelInsertInput        `json:"tags"`
	Type         *string                       `json:"type"`
	Value        *int64                        `json:"value"`
}

// aggregate max on columns
type ChallengesMaxFields struct {
	Category    *string `json:"category"`
	Description *string `json:"description"`
	ID          *int64  `json:"id"`
	MaxAttempts *int64  `json:"max_attempts"`
	Name        *string `json:"name"`
	State       *string `json:"state"`
	Type        *string `json:"type"`
	Value       *int64  `json:"value"`
}

// aggregate min on columns
type ChallengesMinFields struct {
	Category    *string `json:"category"`
	Description *string `json:"description"`
	ID          *int64  `json:"id"`
	MaxAttempts *int64  `json:"max_attempts"`
	Name        *string `json:"name"`
	State       *string `json:"state"`
	Type        *string `json:"type"`
	Value       *int64  `json:"value"`
}

// response of any mutation on the table "challenges"
type ChallengesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Challenges `json:"returning"`
}

// input type for inserting object relation for remote table "challenges"
type ChallengesObjRelInsertInput struct {
	Data *ChallengesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *ChallengesOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "challenges"
type ChallengesOnConflict struct {
	Constraint    ChallengesConstraint     `json:"constraint"`
	UpdateColumns []ChallengesUpdateColumn `json:"update_columns"`
	Where         *ChallengesBoolExp       `json:"where"`
}

// Ordering options when selecting data from "challenges".
type ChallengesOrderBy struct {
	Category             *OrderBy                     `json:"category"`
	CommentsAggregate    *CommentsAggregateOrderBy    `json:"comments_aggregate"`
	Description          *OrderBy                     `json:"description"`
	FilesAggregate       *FilesAggregateOrderBy       `json:"files_aggregate"`
	FlagsAggregate       *FlagsAggregateOrderBy       `json:"flags_aggregate"`
	HintsAggregate       *HintsAggregateOrderBy       `json:"hints_aggregate"`
	ID                   *OrderBy                     `json:"id"`
	MaxAttempts          *OrderBy                     `json:"max_attempts"`
	Name                 *OrderBy                     `json:"name"`
	Requirements         *OrderBy                     `json:"requirements"`
	SolvesAggregate      *SolvesAggregateOrderBy      `json:"solves_aggregate"`
	State                *OrderBy                     `json:"state"`
	SubmissionsAggregate *SubmissionsAggregateOrderBy `json:"submissions_aggregate"`
	TagsAggregate        *TagsAggregateOrderBy        `json:"tags_aggregate"`
	Type                 *OrderBy                     `json:"type"`
	Value                *OrderBy                     `json:"value"`
}

// primary key columns input for table: challenges
type ChallengesPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "challenges"
type ChallengesSetInput struct {
	Category     *string `json:"category"`
	Description  *string `json:"description"`
	ID           *int64  `json:"id"`
	MaxAttempts  *int64  `json:"max_attempts"`
	Name         *string `json:"name"`
	Requirements *string `json:"requirements"`
	State        *string `json:"state"`
	Type         *string `json:"type"`
	Value        *int64  `json:"value"`
}

// aggregate stddev on columns
type ChallengesStddevFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// aggregate stddev_pop on columns
type ChallengesStddevPopFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// aggregate stddev_samp on columns
type ChallengesStddevSampFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// aggregate sum on columns
type ChallengesSumFields struct {
	ID          *int64 `json:"id"`
	MaxAttempts *int64 `json:"max_attempts"`
	Value       *int64 `json:"value"`
}

// aggregate var_pop on columns
type ChallengesVarPopFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// aggregate var_samp on columns
type ChallengesVarSampFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// aggregate variance on columns
type ChallengesVarianceFields struct {
	ID          *float64 `json:"id"`
	MaxAttempts *float64 `json:"max_attempts"`
	Value       *float64 `json:"value"`
}

// columns and relationships of "comments"
type Comments struct {
	AuthorID *int64 `json:"author_id"`
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	Content     *string     `json:"content"`
	Date        *time.Time  `json:"date"`
	ID          int64       `json:"id"`
	// An object relationship
	Page   *Pages `json:"page"`
	PageID *int64 `json:"page_id"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Type   *string `json:"type"`
	// An object relationship
	User *Users `json:"user"`
	// An object relationship
	UserByUserID *Users `json:"userByUserId"`
	UserID       *int64 `json:"user_id"`
}

// aggregated selection of "comments"
type CommentsAggregate struct {
	Aggregate *CommentsAggregateFields `json:"aggregate"`
	Nodes     []*Comments              `json:"nodes"`
}

// aggregate fields of "comments"
type CommentsAggregateFields struct {
	Avg        *CommentsAvgFields        `json:"avg"`
	Count      int64                     `json:"count"`
	Max        *CommentsMaxFields        `json:"max"`
	Min        *CommentsMinFields        `json:"min"`
	Stddev     *CommentsStddevFields     `json:"stddev"`
	StddevPop  *CommentsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *CommentsStddevSampFields `json:"stddev_samp"`
	Sum        *CommentsSumFields        `json:"sum"`
	VarPop     *CommentsVarPopFields     `json:"var_pop"`
	VarSamp    *CommentsVarSampFields    `json:"var_samp"`
	Variance   *CommentsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "comments"
type CommentsAggregateOrderBy struct {
	Avg        *CommentsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                   `json:"count"`
	Max        *CommentsMaxOrderBy        `json:"max"`
	Min        *CommentsMinOrderBy        `json:"min"`
	Stddev     *CommentsStddevOrderBy     `json:"stddev"`
	StddevPop  *CommentsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *CommentsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *CommentsSumOrderBy        `json:"sum"`
	VarPop     *CommentsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *CommentsVarSampOrderBy    `json:"var_samp"`
	Variance   *CommentsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "comments"
type CommentsArrRelInsertInput struct {
	Data []*CommentsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *CommentsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type CommentsAvgFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by avg() on columns of table "comments"
type CommentsAvgOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'.
type CommentsBoolExp struct {
	And          []*CommentsBoolExp      `json:"_and"`
	Not          *CommentsBoolExp        `json:"_not"`
	Or           []*CommentsBoolExp      `json:"_or"`
	AuthorID     *IntComparisonExp       `json:"author_id"`
	Challenge    *ChallengesBoolExp      `json:"challenge"`
	ChallengeID  *IntComparisonExp       `json:"challenge_id"`
	Content      *StringComparisonExp    `json:"content"`
	Date         *TimestampComparisonExp `json:"date"`
	ID           *IntComparisonExp       `json:"id"`
	Page         *PagesBoolExp           `json:"page"`
	PageID       *IntComparisonExp       `json:"page_id"`
	Team         *TeamsBoolExp           `json:"team"`
	TeamID       *IntComparisonExp       `json:"team_id"`
	Type         *StringComparisonExp    `json:"type"`
	User         *UsersBoolExp           `json:"user"`
	UserByUserID *UsersBoolExp           `json:"userByUserId"`
	UserID       *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "comments"
type CommentsIncInput struct {
	AuthorID    *int64 `json:"author_id"`
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	PageID      *int64 `json:"page_id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// input type for inserting data into table "comments"
type CommentsInsertInput struct {
	AuthorID     *int64                       `json:"author_id"`
	Challenge    *ChallengesObjRelInsertInput `json:"challenge"`
	ChallengeID  *int64                       `json:"challenge_id"`
	Content      *string                      `json:"content"`
	Date         *time.Time                   `json:"date"`
	ID           *int64                       `json:"id"`
	Page         *PagesObjRelInsertInput      `json:"page"`
	PageID       *int64                       `json:"page_id"`
	Team         *TeamsObjRelInsertInput      `json:"team"`
	TeamID       *int64                       `json:"team_id"`
	Type         *string                      `json:"type"`
	User         *UsersObjRelInsertInput      `json:"user"`
	UserByUserID *UsersObjRelInsertInput      `json:"userByUserId"`
	UserID       *int64                       `json:"user_id"`
}

// aggregate max on columns
type CommentsMaxFields struct {
	AuthorID    *int64     `json:"author_id"`
	ChallengeID *int64     `json:"challenge_id"`
	Content     *string    `json:"content"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	PageID      *int64     `json:"page_id"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// order by max() on columns of table "comments"
type CommentsMaxOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Date        *OrderBy `json:"date"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate min on columns
type CommentsMinFields struct {
	AuthorID    *int64     `json:"author_id"`
	ChallengeID *int64     `json:"challenge_id"`
	Content     *string    `json:"content"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	PageID      *int64     `json:"page_id"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// order by min() on columns of table "comments"
type CommentsMinOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Date        *OrderBy `json:"date"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
}

// response of any mutation on the table "comments"
type CommentsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Comments `json:"returning"`
}

// on conflict condition type for table "comments"
type CommentsOnConflict struct {
	Constraint    CommentsConstraint     `json:"constraint"`
	UpdateColumns []CommentsUpdateColumn `json:"update_columns"`
	Where         *CommentsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "comments".
type CommentsOrderBy struct {
	AuthorID     *OrderBy           `json:"author_id"`
	Challenge    *ChallengesOrderBy `json:"challenge"`
	ChallengeID  *OrderBy           `json:"challenge_id"`
	Content      *OrderBy           `json:"content"`
	Date         *OrderBy           `json:"date"`
	ID           *OrderBy           `json:"id"`
	Page         *PagesOrderBy      `json:"page"`
	PageID       *OrderBy           `json:"page_id"`
	Team         *TeamsOrderBy      `json:"team"`
	TeamID       *OrderBy           `json:"team_id"`
	Type         *OrderBy           `json:"type"`
	User         *UsersOrderBy      `json:"user"`
	UserByUserID *UsersOrderBy      `json:"userByUserId"`
	UserID       *OrderBy           `json:"user_id"`
}

// primary key columns input for table: comments
type CommentsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "comments"
type CommentsSetInput struct {
	AuthorID    *int64     `json:"author_id"`
	ChallengeID *int64     `json:"challenge_id"`
	Content     *string    `json:"content"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	PageID      *int64     `json:"page_id"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// aggregate stddev on columns
type CommentsStddevFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev() on columns of table "comments"
type CommentsStddevOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type CommentsStddevPopFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "comments"
type CommentsStddevPopOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type CommentsStddevSampFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "comments"
type CommentsStddevSampOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type CommentsSumFields struct {
	AuthorID    *int64 `json:"author_id"`
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	PageID      *int64 `json:"page_id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// order by sum() on columns of table "comments"
type CommentsSumOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type CommentsVarPopFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "comments"
type CommentsVarPopOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type CommentsVarSampFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "comments"
type CommentsVarSampOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type CommentsVarianceFields struct {
	AuthorID    *float64 `json:"author_id"`
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by variance() on columns of table "comments"
type CommentsVarianceOrderBy struct {
	AuthorID    *OrderBy `json:"author_id"`
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// columns and relationships of "config"
type ClientConfig struct {
	ID    int64   `json:"id"`
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

// aggregated selection of "config"
type ConfigAggregate struct {
	Aggregate *ConfigAggregateFields `json:"aggregate"`
	Nodes     []*ClientConfig        `json:"nodes"`
}

// aggregate fields of "config"
type ConfigAggregateFields struct {
	Avg        *ConfigAvgFields        `json:"avg"`
	Count      int64                   `json:"count"`
	Max        *ConfigMaxFields        `json:"max"`
	Min        *ConfigMinFields        `json:"min"`
	Stddev     *ConfigStddevFields     `json:"stddev"`
	StddevPop  *ConfigStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ConfigStddevSampFields `json:"stddev_samp"`
	Sum        *ConfigSumFields        `json:"sum"`
	VarPop     *ConfigVarPopFields     `json:"var_pop"`
	VarSamp    *ConfigVarSampFields    `json:"var_samp"`
	Variance   *ConfigVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type ConfigAvgFields struct {
	ID *float64 `json:"id"`
}

// Boolean expression to filter rows from the table "config". All fields are combined with a logical 'AND'.
type ConfigBoolExp struct {
	And   []*ConfigBoolExp     `json:"_and"`
	Not   *ConfigBoolExp       `json:"_not"`
	Or    []*ConfigBoolExp     `json:"_or"`
	ID    *IntComparisonExp    `json:"id"`
	Key   *StringComparisonExp `json:"key"`
	Value *StringComparisonExp `json:"value"`
}

// input type for incrementing numeric columns in table "config"
type ConfigIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "config"
type ConfigInsertInput struct {
	ID    *int64  `json:"id"`
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

// aggregate max on columns
type ConfigMaxFields struct {
	ID    *int64  `json:"id"`
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

// aggregate min on columns
type ConfigMinFields struct {
	ID    *int64  `json:"id"`
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

// response of any mutation on the table "config"
type ConfigMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*ClientConfig `json:"returning"`
}

// on conflict condition type for table "config"
type ConfigOnConflict struct {
	Constraint    ConfigConstraint     `json:"constraint"`
	UpdateColumns []ConfigUpdateColumn `json:"update_columns"`
	Where         *ConfigBoolExp       `json:"where"`
}

// Ordering options when selecting data from "config".
type ConfigOrderBy struct {
	ID    *OrderBy `json:"id"`
	Key   *OrderBy `json:"key"`
	Value *OrderBy `json:"value"`
}

// primary key columns input for table: config
type ConfigPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "config"
type ConfigSetInput struct {
	ID    *int64  `json:"id"`
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

// aggregate stddev on columns
type ConfigStddevFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_pop on columns
type ConfigStddevPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_samp on columns
type ConfigStddevSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate sum on columns
type ConfigSumFields struct {
	ID *int64 `json:"id"`
}

// aggregate var_pop on columns
type ConfigVarPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate var_samp on columns
type ConfigVarSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate variance on columns
type ConfigVarianceFields struct {
	ID *float64 `json:"id"`
}

// columns and relationships of "dynamic_challenge"
type DynamicChallenge struct {
	// An object relationship
	Challenge *Challenges `json:"challenge"`
	Decay     *int64      `json:"decay"`
	ID        int64       `json:"id"`
	Initial   *int64      `json:"initial"`
	Minimum   *int64      `json:"minimum"`
}

// aggregated selection of "dynamic_challenge"
type DynamicChallengeAggregate struct {
	Aggregate *DynamicChallengeAggregateFields `json:"aggregate"`
	Nodes     []*DynamicChallenge              `json:"nodes"`
}

// aggregate fields of "dynamic_challenge"
type DynamicChallengeAggregateFields struct {
	Avg        *DynamicChallengeAvgFields        `json:"avg"`
	Count      int64                             `json:"count"`
	Max        *DynamicChallengeMaxFields        `json:"max"`
	Min        *DynamicChallengeMinFields        `json:"min"`
	Stddev     *DynamicChallengeStddevFields     `json:"stddev"`
	StddevPop  *DynamicChallengeStddevPopFields  `json:"stddev_pop"`
	StddevSamp *DynamicChallengeStddevSampFields `json:"stddev_samp"`
	Sum        *DynamicChallengeSumFields        `json:"sum"`
	VarPop     *DynamicChallengeVarPopFields     `json:"var_pop"`
	VarSamp    *DynamicChallengeVarSampFields    `json:"var_samp"`
	Variance   *DynamicChallengeVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type DynamicChallengeAvgFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// Boolean expression to filter rows from the table "dynamic_challenge". All fields are combined with a logical 'AND'.
type DynamicChallengeBoolExp struct {
	And       []*DynamicChallengeBoolExp `json:"_and"`
	Not       *DynamicChallengeBoolExp   `json:"_not"`
	Or        []*DynamicChallengeBoolExp `json:"_or"`
	Challenge *ChallengesBoolExp         `json:"challenge"`
	Decay     *IntComparisonExp          `json:"decay"`
	ID        *IntComparisonExp          `json:"id"`
	Initial   *IntComparisonExp          `json:"initial"`
	Minimum   *IntComparisonExp          `json:"minimum"`
}

// input type for incrementing numeric columns in table "dynamic_challenge"
type DynamicChallengeIncInput struct {
	Decay   *int64 `json:"decay"`
	ID      *int64 `json:"id"`
	Initial *int64 `json:"initial"`
	Minimum *int64 `json:"minimum"`
}

// input type for inserting data into table "dynamic_challenge"
type DynamicChallengeInsertInput struct {
	Challenge *ChallengesObjRelInsertInput `json:"challenge"`
	Decay     *int64                       `json:"decay"`
	ID        *int64                       `json:"id"`
	Initial   *int64                       `json:"initial"`
	Minimum   *int64                       `json:"minimum"`
}

// aggregate max on columns
type DynamicChallengeMaxFields struct {
	Decay   *int64 `json:"decay"`
	ID      *int64 `json:"id"`
	Initial *int64 `json:"initial"`
	Minimum *int64 `json:"minimum"`
}

// aggregate min on columns
type DynamicChallengeMinFields struct {
	Decay   *int64 `json:"decay"`
	ID      *int64 `json:"id"`
	Initial *int64 `json:"initial"`
	Minimum *int64 `json:"minimum"`
}

// response of any mutation on the table "dynamic_challenge"
type DynamicChallengeMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*DynamicChallenge `json:"returning"`
}

// on conflict condition type for table "dynamic_challenge"
type DynamicChallengeOnConflict struct {
	Constraint    DynamicChallengeConstraint     `json:"constraint"`
	UpdateColumns []DynamicChallengeUpdateColumn `json:"update_columns"`
	Where         *DynamicChallengeBoolExp       `json:"where"`
}

// Ordering options when selecting data from "dynamic_challenge".
type DynamicChallengeOrderBy struct {
	Challenge *ChallengesOrderBy `json:"challenge"`
	Decay     *OrderBy           `json:"decay"`
	ID        *OrderBy           `json:"id"`
	Initial   *OrderBy           `json:"initial"`
	Minimum   *OrderBy           `json:"minimum"`
}

// primary key columns input for table: dynamic_challenge
type DynamicChallengePkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "dynamic_challenge"
type DynamicChallengeSetInput struct {
	Decay   *int64 `json:"decay"`
	ID      *int64 `json:"id"`
	Initial *int64 `json:"initial"`
	Minimum *int64 `json:"minimum"`
}

// aggregate stddev on columns
type DynamicChallengeStddevFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// aggregate stddev_pop on columns
type DynamicChallengeStddevPopFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// aggregate stddev_samp on columns
type DynamicChallengeStddevSampFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// aggregate sum on columns
type DynamicChallengeSumFields struct {
	Decay   *int64 `json:"decay"`
	ID      *int64 `json:"id"`
	Initial *int64 `json:"initial"`
	Minimum *int64 `json:"minimum"`
}

// aggregate var_pop on columns
type DynamicChallengeVarPopFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// aggregate var_samp on columns
type DynamicChallengeVarSampFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// aggregate variance on columns
type DynamicChallengeVarianceFields struct {
	Decay   *float64 `json:"decay"`
	ID      *float64 `json:"id"`
	Initial *float64 `json:"initial"`
	Minimum *float64 `json:"minimum"`
}

// columns and relationships of "field_entries"
type FieldEntries struct {
	// An object relationship
	Field   *Fields `json:"field"`
	FieldID *int64  `json:"field_id"`
	ID      int64   `json:"id"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Type   *string `json:"type"`
	// An object relationship
	User   *Users  `json:"user"`
	UserID *int64  `json:"user_id"`
	Value  *string `json:"value"`
}

// aggregated selection of "field_entries"
type FieldEntriesAggregate struct {
	Aggregate *FieldEntriesAggregateFields `json:"aggregate"`
	Nodes     []*FieldEntries              `json:"nodes"`
}

// aggregate fields of "field_entries"
type FieldEntriesAggregateFields struct {
	Avg        *FieldEntriesAvgFields        `json:"avg"`
	Count      int64                         `json:"count"`
	Max        *FieldEntriesMaxFields        `json:"max"`
	Min        *FieldEntriesMinFields        `json:"min"`
	Stddev     *FieldEntriesStddevFields     `json:"stddev"`
	StddevPop  *FieldEntriesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *FieldEntriesStddevSampFields `json:"stddev_samp"`
	Sum        *FieldEntriesSumFields        `json:"sum"`
	VarPop     *FieldEntriesVarPopFields     `json:"var_pop"`
	VarSamp    *FieldEntriesVarSampFields    `json:"var_samp"`
	Variance   *FieldEntriesVarianceFields   `json:"variance"`
}

// order by aggregate values of table "field_entries"
type FieldEntriesAggregateOrderBy struct {
	Avg        *FieldEntriesAvgOrderBy        `json:"avg"`
	Count      *OrderBy                       `json:"count"`
	Max        *FieldEntriesMaxOrderBy        `json:"max"`
	Min        *FieldEntriesMinOrderBy        `json:"min"`
	Stddev     *FieldEntriesStddevOrderBy     `json:"stddev"`
	StddevPop  *FieldEntriesStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *FieldEntriesStddevSampOrderBy `json:"stddev_samp"`
	Sum        *FieldEntriesSumOrderBy        `json:"sum"`
	VarPop     *FieldEntriesVarPopOrderBy     `json:"var_pop"`
	VarSamp    *FieldEntriesVarSampOrderBy    `json:"var_samp"`
	Variance   *FieldEntriesVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "field_entries"
type FieldEntriesArrRelInsertInput struct {
	Data []*FieldEntriesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *FieldEntriesOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type FieldEntriesAvgFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by avg() on columns of table "field_entries"
type FieldEntriesAvgOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "field_entries". All fields are combined with a logical 'AND'.
type FieldEntriesBoolExp struct {
	And     []*FieldEntriesBoolExp `json:"_and"`
	Not     *FieldEntriesBoolExp   `json:"_not"`
	Or      []*FieldEntriesBoolExp `json:"_or"`
	Field   *FieldsBoolExp         `json:"field"`
	FieldID *IntComparisonExp      `json:"field_id"`
	ID      *IntComparisonExp      `json:"id"`
	Team    *TeamsBoolExp          `json:"team"`
	TeamID  *IntComparisonExp      `json:"team_id"`
	Type    *StringComparisonExp   `json:"type"`
	User    *UsersBoolExp          `json:"user"`
	UserID  *IntComparisonExp      `json:"user_id"`
	Value   *JSONComparisonExp     `json:"value"`
}

// input type for incrementing numeric columns in table "field_entries"
type FieldEntriesIncInput struct {
	FieldID *int64 `json:"field_id"`
	ID      *int64 `json:"id"`
	TeamID  *int64 `json:"team_id"`
	UserID  *int64 `json:"user_id"`
}

// input type for inserting data into table "field_entries"
type FieldEntriesInsertInput struct {
	Field   *FieldsObjRelInsertInput `json:"field"`
	FieldID *int64                   `json:"field_id"`
	ID      *int64                   `json:"id"`
	Team    *TeamsObjRelInsertInput  `json:"team"`
	TeamID  *int64                   `json:"team_id"`
	Type    *string                  `json:"type"`
	User    *UsersObjRelInsertInput  `json:"user"`
	UserID  *int64                   `json:"user_id"`
	Value   *string                  `json:"value"`
}

// aggregate max on columns
type FieldEntriesMaxFields struct {
	FieldID *int64  `json:"field_id"`
	ID      *int64  `json:"id"`
	TeamID  *int64  `json:"team_id"`
	Type    *string `json:"type"`
	UserID  *int64  `json:"user_id"`
}

// order by max() on columns of table "field_entries"
type FieldEntriesMaxOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	Type    *OrderBy `json:"type"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate min on columns
type FieldEntriesMinFields struct {
	FieldID *int64  `json:"field_id"`
	ID      *int64  `json:"id"`
	TeamID  *int64  `json:"team_id"`
	Type    *string `json:"type"`
	UserID  *int64  `json:"user_id"`
}

// order by min() on columns of table "field_entries"
type FieldEntriesMinOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	Type    *OrderBy `json:"type"`
	UserID  *OrderBy `json:"user_id"`
}

// response of any mutation on the table "field_entries"
type FieldEntriesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*FieldEntries `json:"returning"`
}

// on conflict condition type for table "field_entries"
type FieldEntriesOnConflict struct {
	Constraint    FieldEntriesConstraint     `json:"constraint"`
	UpdateColumns []FieldEntriesUpdateColumn `json:"update_columns"`
	Where         *FieldEntriesBoolExp       `json:"where"`
}

// Ordering options when selecting data from "field_entries".
type FieldEntriesOrderBy struct {
	Field   *FieldsOrderBy `json:"field"`
	FieldID *OrderBy       `json:"field_id"`
	ID      *OrderBy       `json:"id"`
	Team    *TeamsOrderBy  `json:"team"`
	TeamID  *OrderBy       `json:"team_id"`
	Type    *OrderBy       `json:"type"`
	User    *UsersOrderBy  `json:"user"`
	UserID  *OrderBy       `json:"user_id"`
	Value   *OrderBy       `json:"value"`
}

// primary key columns input for table: field_entries
type FieldEntriesPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "field_entries"
type FieldEntriesSetInput struct {
	FieldID *int64  `json:"field_id"`
	ID      *int64  `json:"id"`
	TeamID  *int64  `json:"team_id"`
	Type    *string `json:"type"`
	UserID  *int64  `json:"user_id"`
	Value   *string `json:"value"`
}

// aggregate stddev on columns
type FieldEntriesStddevFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by stddev() on columns of table "field_entries"
type FieldEntriesStddevOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type FieldEntriesStddevPopFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "field_entries"
type FieldEntriesStddevPopOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type FieldEntriesStddevSampFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "field_entries"
type FieldEntriesStddevSampOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type FieldEntriesSumFields struct {
	FieldID *int64 `json:"field_id"`
	ID      *int64 `json:"id"`
	TeamID  *int64 `json:"team_id"`
	UserID  *int64 `json:"user_id"`
}

// order by sum() on columns of table "field_entries"
type FieldEntriesSumOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type FieldEntriesVarPopFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "field_entries"
type FieldEntriesVarPopOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type FieldEntriesVarSampFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "field_entries"
type FieldEntriesVarSampOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type FieldEntriesVarianceFields struct {
	FieldID *float64 `json:"field_id"`
	ID      *float64 `json:"id"`
	TeamID  *float64 `json:"team_id"`
	UserID  *float64 `json:"user_id"`
}

// order by variance() on columns of table "field_entries"
type FieldEntriesVarianceOrderBy struct {
	FieldID *OrderBy `json:"field_id"`
	ID      *OrderBy `json:"id"`
	TeamID  *OrderBy `json:"team_id"`
	UserID  *OrderBy `json:"user_id"`
}

// columns and relationships of "fields"
type Fields struct {
	Description *string `json:"description"`
	Editable    *bool   `json:"editable"`
	// An array relationship
	FieldEntries []*FieldEntries `json:"field_entries"`
	// An aggregate relationship
	FieldEntriesAggregate *FieldEntriesAggregate `json:"field_entries_aggregate"`
	FieldType             *string                `json:"field_type"`
	ID                    int64                  `json:"id"`
	Name                  *string                `json:"name"`
	Public                *bool                  `json:"public"`
	Required              *bool                  `json:"required"`
	Type                  *string                `json:"type"`
}

// aggregated selection of "fields"
type FieldsAggregate struct {
	Aggregate *FieldsAggregateFields `json:"aggregate"`
	Nodes     []*Fields              `json:"nodes"`
}

// aggregate fields of "fields"
type FieldsAggregateFields struct {
	Avg        *FieldsAvgFields        `json:"avg"`
	Count      int64                   `json:"count"`
	Max        *FieldsMaxFields        `json:"max"`
	Min        *FieldsMinFields        `json:"min"`
	Stddev     *FieldsStddevFields     `json:"stddev"`
	StddevPop  *FieldsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *FieldsStddevSampFields `json:"stddev_samp"`
	Sum        *FieldsSumFields        `json:"sum"`
	VarPop     *FieldsVarPopFields     `json:"var_pop"`
	VarSamp    *FieldsVarSampFields    `json:"var_samp"`
	Variance   *FieldsVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type FieldsAvgFields struct {
	ID *float64 `json:"id"`
}

// Boolean expression to filter rows from the table "fields". All fields are combined with a logical 'AND'.
type FieldsBoolExp struct {
	And          []*FieldsBoolExp      `json:"_and"`
	Not          *FieldsBoolExp        `json:"_not"`
	Or           []*FieldsBoolExp      `json:"_or"`
	Description  *StringComparisonExp  `json:"description"`
	Editable     *BooleanComparisonExp `json:"editable"`
	FieldEntries *FieldEntriesBoolExp  `json:"field_entries"`
	FieldType    *StringComparisonExp  `json:"field_type"`
	ID           *IntComparisonExp     `json:"id"`
	Name         *StringComparisonExp  `json:"name"`
	Public       *BooleanComparisonExp `json:"public"`
	Required     *BooleanComparisonExp `json:"required"`
	Type         *StringComparisonExp  `json:"type"`
}

// input type for incrementing numeric columns in table "fields"
type FieldsIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "fields"
type FieldsInsertInput struct {
	Description  *string                        `json:"description"`
	Editable     *bool                          `json:"editable"`
	FieldEntries *FieldEntriesArrRelInsertInput `json:"field_entries"`
	FieldType    *string                        `json:"field_type"`
	ID           *int64                         `json:"id"`
	Name         *string                        `json:"name"`
	Public       *bool                          `json:"public"`
	Required     *bool                          `json:"required"`
	Type         *string                        `json:"type"`
}

// aggregate max on columns
type FieldsMaxFields struct {
	Description *string `json:"description"`
	FieldType   *string `json:"field_type"`
	ID          *int64  `json:"id"`
	Name        *string `json:"name"`
	Type        *string `json:"type"`
}

// aggregate min on columns
type FieldsMinFields struct {
	Description *string `json:"description"`
	FieldType   *string `json:"field_type"`
	ID          *int64  `json:"id"`
	Name        *string `json:"name"`
	Type        *string `json:"type"`
}

// response of any mutation on the table "fields"
type FieldsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Fields `json:"returning"`
}

// input type for inserting object relation for remote table "fields"
type FieldsObjRelInsertInput struct {
	Data *FieldsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *FieldsOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "fields"
type FieldsOnConflict struct {
	Constraint    FieldsConstraint     `json:"constraint"`
	UpdateColumns []FieldsUpdateColumn `json:"update_columns"`
	Where         *FieldsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "fields".
type FieldsOrderBy struct {
	Description           *OrderBy                      `json:"description"`
	Editable              *OrderBy                      `json:"editable"`
	FieldEntriesAggregate *FieldEntriesAggregateOrderBy `json:"field_entries_aggregate"`
	FieldType             *OrderBy                      `json:"field_type"`
	ID                    *OrderBy                      `json:"id"`
	Name                  *OrderBy                      `json:"name"`
	Public                *OrderBy                      `json:"public"`
	Required              *OrderBy                      `json:"required"`
	Type                  *OrderBy                      `json:"type"`
}

// primary key columns input for table: fields
type FieldsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "fields"
type FieldsSetInput struct {
	Description *string `json:"description"`
	Editable    *bool   `json:"editable"`
	FieldType   *string `json:"field_type"`
	ID          *int64  `json:"id"`
	Name        *string `json:"name"`
	Public      *bool   `json:"public"`
	Required    *bool   `json:"required"`
	Type        *string `json:"type"`
}

// aggregate stddev on columns
type FieldsStddevFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_pop on columns
type FieldsStddevPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_samp on columns
type FieldsStddevSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate sum on columns
type FieldsSumFields struct {
	ID *int64 `json:"id"`
}

// aggregate var_pop on columns
type FieldsVarPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate var_samp on columns
type FieldsVarSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate variance on columns
type FieldsVarianceFields struct {
	ID *float64 `json:"id"`
}

// columns and relationships of "files"
type Files struct {
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	ID          int64       `json:"id"`
	Location    *string     `json:"location"`
	// An object relationship
	Page   *Pages  `json:"page"`
	PageID *int64  `json:"page_id"`
	Type   *string `json:"type"`
}

// aggregated selection of "files"
type FilesAggregate struct {
	Aggregate *FilesAggregateFields `json:"aggregate"`
	Nodes     []*Files              `json:"nodes"`
}

// aggregate fields of "files"
type FilesAggregateFields struct {
	Avg        *FilesAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *FilesMaxFields        `json:"max"`
	Min        *FilesMinFields        `json:"min"`
	Stddev     *FilesStddevFields     `json:"stddev"`
	StddevPop  *FilesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *FilesStddevSampFields `json:"stddev_samp"`
	Sum        *FilesSumFields        `json:"sum"`
	VarPop     *FilesVarPopFields     `json:"var_pop"`
	VarSamp    *FilesVarSampFields    `json:"var_samp"`
	Variance   *FilesVarianceFields   `json:"variance"`
}

// order by aggregate values of table "files"
type FilesAggregateOrderBy struct {
	Avg        *FilesAvgOrderBy        `json:"avg"`
	Count      *OrderBy                `json:"count"`
	Max        *FilesMaxOrderBy        `json:"max"`
	Min        *FilesMinOrderBy        `json:"min"`
	Stddev     *FilesStddevOrderBy     `json:"stddev"`
	StddevPop  *FilesStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *FilesStddevSampOrderBy `json:"stddev_samp"`
	Sum        *FilesSumOrderBy        `json:"sum"`
	VarPop     *FilesVarPopOrderBy     `json:"var_pop"`
	VarSamp    *FilesVarSampOrderBy    `json:"var_samp"`
	Variance   *FilesVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "files"
type FilesArrRelInsertInput struct {
	Data []*FilesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *FilesOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type FilesAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by avg() on columns of table "files"
type FilesAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
type FilesBoolExp struct {
	And         []*FilesBoolExp      `json:"_and"`
	Not         *FilesBoolExp        `json:"_not"`
	Or          []*FilesBoolExp      `json:"_or"`
	Challenge   *ChallengesBoolExp   `json:"challenge"`
	ChallengeID *IntComparisonExp    `json:"challenge_id"`
	ID          *IntComparisonExp    `json:"id"`
	Location    *StringComparisonExp `json:"location"`
	Page        *PagesBoolExp        `json:"page"`
	PageID      *IntComparisonExp    `json:"page_id"`
	Type        *StringComparisonExp `json:"type"`
}

// input type for incrementing numeric columns in table "files"
type FilesIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	PageID      *int64 `json:"page_id"`
}

// input type for inserting data into table "files"
type FilesInsertInput struct {
	Challenge   *ChallengesObjRelInsertInput `json:"challenge"`
	ChallengeID *int64                       `json:"challenge_id"`
	ID          *int64                       `json:"id"`
	Location    *string                      `json:"location"`
	Page        *PagesObjRelInsertInput      `json:"page"`
	PageID      *int64                       `json:"page_id"`
	Type        *string                      `json:"type"`
}

// aggregate max on columns
type FilesMaxFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Location    *string `json:"location"`
	PageID      *int64  `json:"page_id"`
	Type        *string `json:"type"`
}

// order by max() on columns of table "files"
type FilesMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	Location    *OrderBy `json:"location"`
	PageID      *OrderBy `json:"page_id"`
	Type        *OrderBy `json:"type"`
}

// aggregate min on columns
type FilesMinFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Location    *string `json:"location"`
	PageID      *int64  `json:"page_id"`
	Type        *string `json:"type"`
}

// order by min() on columns of table "files"
type FilesMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	Location    *OrderBy `json:"location"`
	PageID      *OrderBy `json:"page_id"`
	Type        *OrderBy `json:"type"`
}

// response of any mutation on the table "files"
type FilesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Files `json:"returning"`
}

// on conflict condition type for table "files"
type FilesOnConflict struct {
	Constraint    FilesConstraint     `json:"constraint"`
	UpdateColumns []FilesUpdateColumn `json:"update_columns"`
	Where         *FilesBoolExp       `json:"where"`
}

// Ordering options when selecting data from "files".
type FilesOrderBy struct {
	Challenge   *ChallengesOrderBy `json:"challenge"`
	ChallengeID *OrderBy           `json:"challenge_id"`
	ID          *OrderBy           `json:"id"`
	Location    *OrderBy           `json:"location"`
	Page        *PagesOrderBy      `json:"page"`
	PageID      *OrderBy           `json:"page_id"`
	Type        *OrderBy           `json:"type"`
}

// primary key columns input for table: files
type FilesPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "files"
type FilesSetInput struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Location    *string `json:"location"`
	PageID      *int64  `json:"page_id"`
	Type        *string `json:"type"`
}

// aggregate stddev on columns
type FilesStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by stddev() on columns of table "files"
type FilesStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate stddev_pop on columns
type FilesStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by stddev_pop() on columns of table "files"
type FilesStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate stddev_samp on columns
type FilesStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by stddev_samp() on columns of table "files"
type FilesStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate sum on columns
type FilesSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	PageID      *int64 `json:"page_id"`
}

// order by sum() on columns of table "files"
type FilesSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate var_pop on columns
type FilesVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by var_pop() on columns of table "files"
type FilesVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate var_samp on columns
type FilesVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by var_samp() on columns of table "files"
type FilesVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// aggregate variance on columns
type FilesVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	PageID      *float64 `json:"page_id"`
}

// order by variance() on columns of table "files"
type FilesVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	PageID      *OrderBy `json:"page_id"`
}

// columns and relationships of "flags"
type Flags struct {
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	Content     *string     `json:"content"`
	Data        *string     `json:"data"`
	ID          int64       `json:"id"`
	Type        *string     `json:"type"`
}

// aggregated selection of "flags"
type FlagsAggregate struct {
	Aggregate *FlagsAggregateFields `json:"aggregate"`
	Nodes     []*Flags              `json:"nodes"`
}

// aggregate fields of "flags"
type FlagsAggregateFields struct {
	Avg        *FlagsAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *FlagsMaxFields        `json:"max"`
	Min        *FlagsMinFields        `json:"min"`
	Stddev     *FlagsStddevFields     `json:"stddev"`
	StddevPop  *FlagsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *FlagsStddevSampFields `json:"stddev_samp"`
	Sum        *FlagsSumFields        `json:"sum"`
	VarPop     *FlagsVarPopFields     `json:"var_pop"`
	VarSamp    *FlagsVarSampFields    `json:"var_samp"`
	Variance   *FlagsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "flags"
type FlagsAggregateOrderBy struct {
	Avg        *FlagsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                `json:"count"`
	Max        *FlagsMaxOrderBy        `json:"max"`
	Min        *FlagsMinOrderBy        `json:"min"`
	Stddev     *FlagsStddevOrderBy     `json:"stddev"`
	StddevPop  *FlagsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *FlagsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *FlagsSumOrderBy        `json:"sum"`
	VarPop     *FlagsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *FlagsVarSampOrderBy    `json:"var_samp"`
	Variance   *FlagsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "flags"
type FlagsArrRelInsertInput struct {
	Data []*FlagsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *FlagsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type FlagsAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by avg() on columns of table "flags"
type FlagsAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "flags". All fields are combined with a logical 'AND'.
type FlagsBoolExp struct {
	And         []*FlagsBoolExp      `json:"_and"`
	Not         *FlagsBoolExp        `json:"_not"`
	Or          []*FlagsBoolExp      `json:"_or"`
	Challenge   *ChallengesBoolExp   `json:"challenge"`
	ChallengeID *IntComparisonExp    `json:"challenge_id"`
	Content     *StringComparisonExp `json:"content"`
	Data        *StringComparisonExp `json:"data"`
	ID          *IntComparisonExp    `json:"id"`
	Type        *StringComparisonExp `json:"type"`
}

// input type for incrementing numeric columns in table "flags"
type FlagsIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
}

// input type for inserting data into table "flags"
type FlagsInsertInput struct {
	Challenge   *ChallengesObjRelInsertInput `json:"challenge"`
	ChallengeID *int64                       `json:"challenge_id"`
	Content     *string                      `json:"content"`
	Data        *string                      `json:"data"`
	ID          *int64                       `json:"id"`
	Type        *string                      `json:"type"`
}

// aggregate max on columns
type FlagsMaxFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	Content     *string `json:"content"`
	Data        *string `json:"data"`
	ID          *int64  `json:"id"`
	Type        *string `json:"type"`
}

// order by max() on columns of table "flags"
type FlagsMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Data        *OrderBy `json:"data"`
	ID          *OrderBy `json:"id"`
	Type        *OrderBy `json:"type"`
}

// aggregate min on columns
type FlagsMinFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	Content     *string `json:"content"`
	Data        *string `json:"data"`
	ID          *int64  `json:"id"`
	Type        *string `json:"type"`
}

// order by min() on columns of table "flags"
type FlagsMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Data        *OrderBy `json:"data"`
	ID          *OrderBy `json:"id"`
	Type        *OrderBy `json:"type"`
}

// response of any mutation on the table "flags"
type FlagsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Flags `json:"returning"`
}

// on conflict condition type for table "flags"
type FlagsOnConflict struct {
	Constraint    FlagsConstraint     `json:"constraint"`
	UpdateColumns []FlagsUpdateColumn `json:"update_columns"`
	Where         *FlagsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "flags".
type FlagsOrderBy struct {
	Challenge   *ChallengesOrderBy `json:"challenge"`
	ChallengeID *OrderBy           `json:"challenge_id"`
	Content     *OrderBy           `json:"content"`
	Data        *OrderBy           `json:"data"`
	ID          *OrderBy           `json:"id"`
	Type        *OrderBy           `json:"type"`
}

// primary key columns input for table: flags
type FlagsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "flags"
type FlagsSetInput struct {
	ChallengeID *int64  `json:"challenge_id"`
	Content     *string `json:"content"`
	Data        *string `json:"data"`
	ID          *int64  `json:"id"`
	Type        *string `json:"type"`
}

// aggregate stddev on columns
type FlagsStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev() on columns of table "flags"
type FlagsStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type FlagsStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "flags"
type FlagsStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type FlagsStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "flags"
type FlagsStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate sum on columns
type FlagsSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
}

// order by sum() on columns of table "flags"
type FlagsSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_pop on columns
type FlagsVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by var_pop() on columns of table "flags"
type FlagsVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_samp on columns
type FlagsVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by var_samp() on columns of table "flags"
type FlagsVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate variance on columns
type FlagsVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by variance() on columns of table "flags"
type FlagsVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// columns and relationships of "hints"
type Hints struct {
	// An object relationship
	Challenge    *Challenges `json:"challenge"`
	ChallengeID  *int64      `json:"challenge_id"`
	Content      *string     `json:"content"`
	Cost         *int64      `json:"cost"`
	ID           int64       `json:"id"`
	Requirements *string     `json:"requirements"`
	Type         *string     `json:"type"`
	// An object relationship
	UnlockedContent *HintsContent `json:"unlocked_content"`
	// An array relationship
	Unlocks []*Unlocks `json:"unlocks"`
	// An aggregate relationship
	UnlocksAggregate *UnlocksAggregate `json:"unlocks_aggregate"`
}

// aggregated selection of "hints"
type HintsAggregate struct {
	Aggregate *HintsAggregateFields `json:"aggregate"`
	Nodes     []*Hints              `json:"nodes"`
}

// aggregate fields of "hints"
type HintsAggregateFields struct {
	Avg        *HintsAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *HintsMaxFields        `json:"max"`
	Min        *HintsMinFields        `json:"min"`
	Stddev     *HintsStddevFields     `json:"stddev"`
	StddevPop  *HintsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *HintsStddevSampFields `json:"stddev_samp"`
	Sum        *HintsSumFields        `json:"sum"`
	VarPop     *HintsVarPopFields     `json:"var_pop"`
	VarSamp    *HintsVarSampFields    `json:"var_samp"`
	Variance   *HintsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "hints"
type HintsAggregateOrderBy struct {
	Avg        *HintsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                `json:"count"`
	Max        *HintsMaxOrderBy        `json:"max"`
	Min        *HintsMinOrderBy        `json:"min"`
	Stddev     *HintsStddevOrderBy     `json:"stddev"`
	StddevPop  *HintsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *HintsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *HintsSumOrderBy        `json:"sum"`
	VarPop     *HintsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *HintsVarSampOrderBy    `json:"var_samp"`
	Variance   *HintsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "hints"
type HintsArrRelInsertInput struct {
	Data []*HintsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *HintsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type HintsAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by avg() on columns of table "hints"
type HintsAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "hints". All fields are combined with a logical 'AND'.
type HintsBoolExp struct {
	And             []*HintsBoolExp      `json:"_and"`
	Not             *HintsBoolExp        `json:"_not"`
	Or              []*HintsBoolExp      `json:"_or"`
	Challenge       *ChallengesBoolExp   `json:"challenge"`
	ChallengeID     *IntComparisonExp    `json:"challenge_id"`
	Content         *StringComparisonExp `json:"content"`
	Cost            *IntComparisonExp    `json:"cost"`
	ID              *IntComparisonExp    `json:"id"`
	Requirements    *JSONComparisonExp   `json:"requirements"`
	Type            *StringComparisonExp `json:"type"`
	UnlockedContent *HintsContentBoolExp `json:"unlocked_content"`
	Unlocks         *UnlocksBoolExp      `json:"unlocks"`
}

// columns and relationships of "hints_content"
type HintsContent struct {
	Content *string `json:"content"`
	// An object relationship
	Hint *Hints `json:"hint"`
	ID   *int64 `json:"id"`
}

// aggregated selection of "hints_content"
type HintsContentAggregate struct {
	Aggregate *HintsContentAggregateFields `json:"aggregate"`
	Nodes     []*HintsContent              `json:"nodes"`
}

// aggregate fields of "hints_content"
type HintsContentAggregateFields struct {
	Avg        *HintsContentAvgFields        `json:"avg"`
	Count      int64                         `json:"count"`
	Max        *HintsContentMaxFields        `json:"max"`
	Min        *HintsContentMinFields        `json:"min"`
	Stddev     *HintsContentStddevFields     `json:"stddev"`
	StddevPop  *HintsContentStddevPopFields  `json:"stddev_pop"`
	StddevSamp *HintsContentStddevSampFields `json:"stddev_samp"`
	Sum        *HintsContentSumFields        `json:"sum"`
	VarPop     *HintsContentVarPopFields     `json:"var_pop"`
	VarSamp    *HintsContentVarSampFields    `json:"var_samp"`
	Variance   *HintsContentVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type HintsContentAvgFields struct {
	ID *float64 `json:"id"`
}

// Boolean expression to filter rows from the table "hints_content". All fields are combined with a logical 'AND'.
type HintsContentBoolExp struct {
	And     []*HintsContentBoolExp `json:"_and"`
	Not     *HintsContentBoolExp   `json:"_not"`
	Or      []*HintsContentBoolExp `json:"_or"`
	Content *StringComparisonExp   `json:"content"`
	Hint    *HintsBoolExp          `json:"hint"`
	ID      *IntComparisonExp      `json:"id"`
}

// input type for incrementing numeric columns in table "hints_content"
type HintsContentIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "hints_content"
type HintsContentInsertInput struct {
	Content *string                 `json:"content"`
	Hint    *HintsObjRelInsertInput `json:"hint"`
	ID      *int64                  `json:"id"`
}

// aggregate max on columns
type HintsContentMaxFields struct {
	Content *string `json:"content"`
	ID      *int64  `json:"id"`
}

// aggregate min on columns
type HintsContentMinFields struct {
	Content *string `json:"content"`
	ID      *int64  `json:"id"`
}

// response of any mutation on the table "hints_content"
type HintsContentMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*HintsContent `json:"returning"`
}

// input type for inserting object relation for remote table "hints_content"
type HintsContentObjRelInsertInput struct {
	Data *HintsContentInsertInput `json:"data"`
}

// Ordering options when selecting data from "hints_content".
type HintsContentOrderBy struct {
	Content *OrderBy      `json:"content"`
	Hint    *HintsOrderBy `json:"hint"`
	ID      *OrderBy      `json:"id"`
}

// input type for updating data in table "hints_content"
type HintsContentSetInput struct {
	Content *string `json:"content"`
	ID      *int64  `json:"id"`
}

// aggregate stddev on columns
type HintsContentStddevFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_pop on columns
type HintsContentStddevPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_samp on columns
type HintsContentStddevSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate sum on columns
type HintsContentSumFields struct {
	ID *int64 `json:"id"`
}

// aggregate var_pop on columns
type HintsContentVarPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate var_samp on columns
type HintsContentVarSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate variance on columns
type HintsContentVarianceFields struct {
	ID *float64 `json:"id"`
}

// input type for incrementing numeric columns in table "hints"
type HintsIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	Cost        *int64 `json:"cost"`
	ID          *int64 `json:"id"`
}

// input type for inserting data into table "hints"
type HintsInsertInput struct {
	Challenge       *ChallengesObjRelInsertInput   `json:"challenge"`
	ChallengeID     *int64                         `json:"challenge_id"`
	Content         *string                        `json:"content"`
	Cost            *int64                         `json:"cost"`
	ID              *int64                         `json:"id"`
	Requirements    *string                        `json:"requirements"`
	Type            *string                        `json:"type"`
	UnlockedContent *HintsContentObjRelInsertInput `json:"unlocked_content"`
	Unlocks         *UnlocksArrRelInsertInput      `json:"unlocks"`
}

// aggregate max on columns
type HintsMaxFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	Content     *string `json:"content"`
	Cost        *int64  `json:"cost"`
	ID          *int64  `json:"id"`
	Type        *string `json:"type"`
}

// order by max() on columns of table "hints"
type HintsMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
	Type        *OrderBy `json:"type"`
}

// aggregate min on columns
type HintsMinFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	Content     *string `json:"content"`
	Cost        *int64  `json:"cost"`
	ID          *int64  `json:"id"`
	Type        *string `json:"type"`
}

// order by min() on columns of table "hints"
type HintsMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Content     *OrderBy `json:"content"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
	Type        *OrderBy `json:"type"`
}

// response of any mutation on the table "hints"
type HintsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Hints `json:"returning"`
}

// input type for inserting object relation for remote table "hints"
type HintsObjRelInsertInput struct {
	Data *HintsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *HintsOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "hints"
type HintsOnConflict struct {
	Constraint    HintsConstraint     `json:"constraint"`
	UpdateColumns []HintsUpdateColumn `json:"update_columns"`
	Where         *HintsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "hints".
type HintsOrderBy struct {
	Challenge        *ChallengesOrderBy       `json:"challenge"`
	ChallengeID      *OrderBy                 `json:"challenge_id"`
	Content          *OrderBy                 `json:"content"`
	Cost             *OrderBy                 `json:"cost"`
	ID               *OrderBy                 `json:"id"`
	Requirements     *OrderBy                 `json:"requirements"`
	Type             *OrderBy                 `json:"type"`
	UnlockedContent  *HintsContentOrderBy     `json:"unlocked_content"`
	UnlocksAggregate *UnlocksAggregateOrderBy `json:"unlocks_aggregate"`
}

// primary key columns input for table: hints
type HintsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "hints"
type HintsSetInput struct {
	ChallengeID  *int64  `json:"challenge_id"`
	Content      *string `json:"content"`
	Cost         *int64  `json:"cost"`
	ID           *int64  `json:"id"`
	Requirements *string `json:"requirements"`
	Type         *string `json:"type"`
}

// aggregate stddev on columns
type HintsStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by stddev() on columns of table "hints"
type HintsStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type HintsStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "hints"
type HintsStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type HintsStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "hints"
type HintsStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate sum on columns
type HintsSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	Cost        *int64 `json:"cost"`
	ID          *int64 `json:"id"`
}

// order by sum() on columns of table "hints"
type HintsSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_pop on columns
type HintsVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by var_pop() on columns of table "hints"
type HintsVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_samp on columns
type HintsVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by var_samp() on columns of table "hints"
type HintsVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// aggregate variance on columns
type HintsVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	Cost        *float64 `json:"cost"`
	ID          *float64 `json:"id"`
}

// order by variance() on columns of table "hints"
type HintsVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Cost        *OrderBy `json:"cost"`
	ID          *OrderBy `json:"id"`
}

// Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
type JSONComparisonExp struct {
	Eq     *string  `json:"_eq"`
	Gt     *string  `json:"_gt"`
	Gte    *string  `json:"_gte"`
	In     []string `json:"_in"`
	IsNull *bool    `json:"_is_null"`
	Lt     *string  `json:"_lt"`
	Lte    *string  `json:"_lte"`
	Neq    *string  `json:"_neq"`
	Nin    []string `json:"_nin"`
}

// columns and relationships of "notifications"
type Notifications struct {
	Content *string    `json:"content"`
	Date    *time.Time `json:"date"`
	ID      int64      `json:"id"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Title  *string `json:"title"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "notifications"
type NotificationsAggregate struct {
	Aggregate *NotificationsAggregateFields `json:"aggregate"`
	Nodes     []*Notifications              `json:"nodes"`
}

// aggregate fields of "notifications"
type NotificationsAggregateFields struct {
	Avg        *NotificationsAvgFields        `json:"avg"`
	Count      int64                          `json:"count"`
	Max        *NotificationsMaxFields        `json:"max"`
	Min        *NotificationsMinFields        `json:"min"`
	Stddev     *NotificationsStddevFields     `json:"stddev"`
	StddevPop  *NotificationsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *NotificationsStddevSampFields `json:"stddev_samp"`
	Sum        *NotificationsSumFields        `json:"sum"`
	VarPop     *NotificationsVarPopFields     `json:"var_pop"`
	VarSamp    *NotificationsVarSampFields    `json:"var_samp"`
	Variance   *NotificationsVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type NotificationsAvgFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
type NotificationsBoolExp struct {
	And     []*NotificationsBoolExp `json:"_and"`
	Not     *NotificationsBoolExp   `json:"_not"`
	Or      []*NotificationsBoolExp `json:"_or"`
	Content *StringComparisonExp    `json:"content"`
	Date    *TimestampComparisonExp `json:"date"`
	ID      *IntComparisonExp       `json:"id"`
	Team    *TeamsBoolExp           `json:"team"`
	TeamID  *IntComparisonExp       `json:"team_id"`
	Title   *StringComparisonExp    `json:"title"`
	User    *UsersBoolExp           `json:"user"`
	UserID  *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "notifications"
type NotificationsIncInput struct {
	ID     *int64 `json:"id"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "notifications"
type NotificationsInsertInput struct {
	Content *string                 `json:"content"`
	Date    *time.Time              `json:"date"`
	ID      *int64                  `json:"id"`
	Team    *TeamsObjRelInsertInput `json:"team"`
	TeamID  *int64                  `json:"team_id"`
	Title   *string                 `json:"title"`
	User    *UsersObjRelInsertInput `json:"user"`
	UserID  *int64                  `json:"user_id"`
}

// aggregate max on columns
type NotificationsMaxFields struct {
	Content *string    `json:"content"`
	Date    *time.Time `json:"date"`
	ID      *int64     `json:"id"`
	TeamID  *int64     `json:"team_id"`
	Title   *string    `json:"title"`
	UserID  *int64     `json:"user_id"`
}

// aggregate min on columns
type NotificationsMinFields struct {
	Content *string    `json:"content"`
	Date    *time.Time `json:"date"`
	ID      *int64     `json:"id"`
	TeamID  *int64     `json:"team_id"`
	Title   *string    `json:"title"`
	UserID  *int64     `json:"user_id"`
}

// response of any mutation on the table "notifications"
type NotificationsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Notifications `json:"returning"`
}

// on conflict condition type for table "notifications"
type NotificationsOnConflict struct {
	Constraint    NotificationsConstraint     `json:"constraint"`
	UpdateColumns []NotificationsUpdateColumn `json:"update_columns"`
	Where         *NotificationsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "notifications".
type NotificationsOrderBy struct {
	Content *OrderBy      `json:"content"`
	Date    *OrderBy      `json:"date"`
	ID      *OrderBy      `json:"id"`
	Team    *TeamsOrderBy `json:"team"`
	TeamID  *OrderBy      `json:"team_id"`
	Title   *OrderBy      `json:"title"`
	User    *UsersOrderBy `json:"user"`
	UserID  *OrderBy      `json:"user_id"`
}

// primary key columns input for table: notifications
type NotificationsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "notifications"
type NotificationsSetInput struct {
	Content *string    `json:"content"`
	Date    *time.Time `json:"date"`
	ID      *int64     `json:"id"`
	TeamID  *int64     `json:"team_id"`
	Title   *string    `json:"title"`
	UserID  *int64     `json:"user_id"`
}

// aggregate stddev on columns
type NotificationsStddevFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate stddev_pop on columns
type NotificationsStddevPopFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate stddev_samp on columns
type NotificationsStddevSampFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate sum on columns
type NotificationsSumFields struct {
	ID     *int64 `json:"id"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// aggregate var_pop on columns
type NotificationsVarPopFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate var_samp on columns
type NotificationsVarSampFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate variance on columns
type NotificationsVarianceFields struct {
	ID     *float64 `json:"id"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// columns and relationships of "pages"
type Pages struct {
	AuthRequired *bool `json:"auth_required"`
	// An array relationship
	Comments []*Comments `json:"comments"`
	// An aggregate relationship
	CommentsAggregate *CommentsAggregate `json:"comments_aggregate"`
	Content           *string            `json:"content"`
	Draft             *bool              `json:"draft"`
	Format            *string            `json:"format"`
	Hidden            *bool              `json:"hidden"`
	ID                int64              `json:"id"`
	Route             *string            `json:"route"`
	Title             *string            `json:"title"`
}

// aggregated selection of "pages"
type PagesAggregate struct {
	Aggregate *PagesAggregateFields `json:"aggregate"`
	Nodes     []*Pages              `json:"nodes"`
}

// aggregate fields of "pages"
type PagesAggregateFields struct {
	Avg        *PagesAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *PagesMaxFields        `json:"max"`
	Min        *PagesMinFields        `json:"min"`
	Stddev     *PagesStddevFields     `json:"stddev"`
	StddevPop  *PagesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *PagesStddevSampFields `json:"stddev_samp"`
	Sum        *PagesSumFields        `json:"sum"`
	VarPop     *PagesVarPopFields     `json:"var_pop"`
	VarSamp    *PagesVarSampFields    `json:"var_samp"`
	Variance   *PagesVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type PagesAvgFields struct {
	ID *float64 `json:"id"`
}

// Boolean expression to filter rows from the table "pages". All fields are combined with a logical 'AND'.
type PagesBoolExp struct {
	And          []*PagesBoolExp       `json:"_and"`
	Not          *PagesBoolExp         `json:"_not"`
	Or           []*PagesBoolExp       `json:"_or"`
	AuthRequired *BooleanComparisonExp `json:"auth_required"`
	Comments     *CommentsBoolExp      `json:"comments"`
	Content      *StringComparisonExp  `json:"content"`
	Draft        *BooleanComparisonExp `json:"draft"`
	Format       *StringComparisonExp  `json:"format"`
	Hidden       *BooleanComparisonExp `json:"hidden"`
	ID           *IntComparisonExp     `json:"id"`
	Route        *StringComparisonExp  `json:"route"`
	Title        *StringComparisonExp  `json:"title"`
}

// input type for incrementing numeric columns in table "pages"
type PagesIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "pages"
type PagesInsertInput struct {
	AuthRequired *bool                      `json:"auth_required"`
	Comments     *CommentsArrRelInsertInput `json:"comments"`
	Content      *string                    `json:"content"`
	Draft        *bool                      `json:"draft"`
	Format       *string                    `json:"format"`
	Hidden       *bool                      `json:"hidden"`
	ID           *int64                     `json:"id"`
	Route        *string                    `json:"route"`
	Title        *string                    `json:"title"`
}

// aggregate max on columns
type PagesMaxFields struct {
	Content *string `json:"content"`
	Format  *string `json:"format"`
	ID      *int64  `json:"id"`
	Route   *string `json:"route"`
	Title   *string `json:"title"`
}

// aggregate min on columns
type PagesMinFields struct {
	Content *string `json:"content"`
	Format  *string `json:"format"`
	ID      *int64  `json:"id"`
	Route   *string `json:"route"`
	Title   *string `json:"title"`
}

// response of any mutation on the table "pages"
type PagesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Pages `json:"returning"`
}

// input type for inserting object relation for remote table "pages"
type PagesObjRelInsertInput struct {
	Data *PagesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *PagesOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "pages"
type PagesOnConflict struct {
	Constraint    PagesConstraint     `json:"constraint"`
	UpdateColumns []PagesUpdateColumn `json:"update_columns"`
	Where         *PagesBoolExp       `json:"where"`
}

// Ordering options when selecting data from "pages".
type PagesOrderBy struct {
	AuthRequired      *OrderBy                  `json:"auth_required"`
	CommentsAggregate *CommentsAggregateOrderBy `json:"comments_aggregate"`
	Content           *OrderBy                  `json:"content"`
	Draft             *OrderBy                  `json:"draft"`
	Format            *OrderBy                  `json:"format"`
	Hidden            *OrderBy                  `json:"hidden"`
	ID                *OrderBy                  `json:"id"`
	Route             *OrderBy                  `json:"route"`
	Title             *OrderBy                  `json:"title"`
}

// primary key columns input for table: pages
type PagesPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "pages"
type PagesSetInput struct {
	AuthRequired *bool   `json:"auth_required"`
	Content      *string `json:"content"`
	Draft        *bool   `json:"draft"`
	Format       *string `json:"format"`
	Hidden       *bool   `json:"hidden"`
	ID           *int64  `json:"id"`
	Route        *string `json:"route"`
	Title        *string `json:"title"`
}

// aggregate stddev on columns
type PagesStddevFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_pop on columns
type PagesStddevPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate stddev_samp on columns
type PagesStddevSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate sum on columns
type PagesSumFields struct {
	ID *int64 `json:"id"`
}

// aggregate var_pop on columns
type PagesVarPopFields struct {
	ID *float64 `json:"id"`
}

// aggregate var_samp on columns
type PagesVarSampFields struct {
	ID *float64 `json:"id"`
}

// aggregate variance on columns
type PagesVarianceFields struct {
	ID *float64 `json:"id"`
}

// columns and relationships of "score_events"
type ScoreEvents struct {
	EventTime  *time.Time `json:"event_time"`
	EventValue *int64     `json:"event_value"`
	TeamID     *int64     `json:"team_id"`
	UserID     *int64     `json:"user_id"`
}

// aggregated selection of "score_events"
type ScoreEventsAggregate struct {
	Aggregate *ScoreEventsAggregateFields `json:"aggregate"`
	Nodes     []*ScoreEvents              `json:"nodes"`
}

// aggregate fields of "score_events"
type ScoreEventsAggregateFields struct {
	Avg        *ScoreEventsAvgFields        `json:"avg"`
	Count      int64                        `json:"count"`
	Max        *ScoreEventsMaxFields        `json:"max"`
	Min        *ScoreEventsMinFields        `json:"min"`
	Stddev     *ScoreEventsStddevFields     `json:"stddev"`
	StddevPop  *ScoreEventsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ScoreEventsStddevSampFields `json:"stddev_samp"`
	Sum        *ScoreEventsSumFields        `json:"sum"`
	VarPop     *ScoreEventsVarPopFields     `json:"var_pop"`
	VarSamp    *ScoreEventsVarSampFields    `json:"var_samp"`
	Variance   *ScoreEventsVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type ScoreEventsAvgFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// Boolean expression to filter rows from the table "score_events". All fields are combined with a logical 'AND'.
type ScoreEventsBoolExp struct {
	And        []*ScoreEventsBoolExp   `json:"_and"`
	Not        *ScoreEventsBoolExp     `json:"_not"`
	Or         []*ScoreEventsBoolExp   `json:"_or"`
	EventTime  *TimestampComparisonExp `json:"event_time"`
	EventValue *IntComparisonExp       `json:"event_value"`
	TeamID     *IntComparisonExp       `json:"team_id"`
	UserID     *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "score_events"
type ScoreEventsIncInput struct {
	EventValue *int64 `json:"event_value"`
	TeamID     *int64 `json:"team_id"`
	UserID     *int64 `json:"user_id"`
}

// input type for inserting data into table "score_events"
type ScoreEventsInsertInput struct {
	EventTime  *time.Time `json:"event_time"`
	EventValue *int64     `json:"event_value"`
	TeamID     *int64     `json:"team_id"`
	UserID     *int64     `json:"user_id"`
}

// aggregate max on columns
type ScoreEventsMaxFields struct {
	EventTime  *time.Time `json:"event_time"`
	EventValue *int64     `json:"event_value"`
	TeamID     *int64     `json:"team_id"`
	UserID     *int64     `json:"user_id"`
}

// aggregate min on columns
type ScoreEventsMinFields struct {
	EventTime  *time.Time `json:"event_time"`
	EventValue *int64     `json:"event_value"`
	TeamID     *int64     `json:"team_id"`
	UserID     *int64     `json:"user_id"`
}

// response of any mutation on the table "score_events"
type ScoreEventsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*ScoreEvents `json:"returning"`
}

// on conflict condition type for table "score_events"
type ScoreEventsOnConflict struct {
	Constraint    ScoreEventsConstraint     `json:"constraint"`
	UpdateColumns []ScoreEventsUpdateColumn `json:"update_columns"`
	Where         *ScoreEventsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "score_events".
type ScoreEventsOrderBy struct {
	EventTime  *OrderBy `json:"event_time"`
	EventValue *OrderBy `json:"event_value"`
	TeamID     *OrderBy `json:"team_id"`
	UserID     *OrderBy `json:"user_id"`
}

// input type for updating data in table "score_events"
type ScoreEventsSetInput struct {
	EventTime  *time.Time `json:"event_time"`
	EventValue *int64     `json:"event_value"`
	TeamID     *int64     `json:"team_id"`
	UserID     *int64     `json:"user_id"`
}

// aggregate stddev on columns
type ScoreEventsStddevFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// aggregate stddev_pop on columns
type ScoreEventsStddevPopFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// aggregate stddev_samp on columns
type ScoreEventsStddevSampFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// aggregate sum on columns
type ScoreEventsSumFields struct {
	EventValue *int64 `json:"event_value"`
	TeamID     *int64 `json:"team_id"`
	UserID     *int64 `json:"user_id"`
}

// aggregate var_pop on columns
type ScoreEventsVarPopFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// aggregate var_samp on columns
type ScoreEventsVarSampFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// aggregate variance on columns
type ScoreEventsVarianceFields struct {
	EventValue *float64 `json:"event_value"`
	TeamID     *float64 `json:"team_id"`
	UserID     *float64 `json:"user_id"`
}

// columns and relationships of "score_timeline"
type ScoreTimeline struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
}

// aggregated selection of "score_timeline"
type ScoreTimelineAggregate struct {
	Aggregate *ScoreTimelineAggregateFields `json:"aggregate"`
	Nodes     []*ScoreTimeline              `json:"nodes"`
}

// aggregate fields of "score_timeline"
type ScoreTimelineAggregateFields struct {
	Avg        *ScoreTimelineAvgFields        `json:"avg"`
	Count      int64                          `json:"count"`
	Max        *ScoreTimelineMaxFields        `json:"max"`
	Min        *ScoreTimelineMinFields        `json:"min"`
	Stddev     *ScoreTimelineStddevFields     `json:"stddev"`
	StddevPop  *ScoreTimelineStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ScoreTimelineStddevSampFields `json:"stddev_samp"`
	Sum        *ScoreTimelineSumFields        `json:"sum"`
	VarPop     *ScoreTimelineVarPopFields     `json:"var_pop"`
	VarSamp    *ScoreTimelineVarSampFields    `json:"var_samp"`
	Variance   *ScoreTimelineVarianceFields   `json:"variance"`
}

// order by aggregate values of table "score_timeline"
type ScoreTimelineAggregateOrderBy struct {
	Avg        *ScoreTimelineAvgOrderBy        `json:"avg"`
	Count      *OrderBy                        `json:"count"`
	Max        *ScoreTimelineMaxOrderBy        `json:"max"`
	Min        *ScoreTimelineMinOrderBy        `json:"min"`
	Stddev     *ScoreTimelineStddevOrderBy     `json:"stddev"`
	StddevPop  *ScoreTimelineStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *ScoreTimelineStddevSampOrderBy `json:"stddev_samp"`
	Sum        *ScoreTimelineSumOrderBy        `json:"sum"`
	VarPop     *ScoreTimelineVarPopOrderBy     `json:"var_pop"`
	VarSamp    *ScoreTimelineVarSampOrderBy    `json:"var_samp"`
	Variance   *ScoreTimelineVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "score_timeline"
type ScoreTimelineArrRelInsertInput struct {
	Data []*ScoreTimelineInsertInput `json:"data"`
}

// aggregate avg on columns
type ScoreTimelineAvgFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by avg() on columns of table "score_timeline"
type ScoreTimelineAvgOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// Boolean expression to filter rows from the table "score_timeline". All fields are combined with a logical 'AND'.
type ScoreTimelineBoolExp struct {
	And       []*ScoreTimelineBoolExp `json:"_and"`
	Not       *ScoreTimelineBoolExp   `json:"_not"`
	Or        []*ScoreTimelineBoolExp `json:"_or"`
	EventTime *TimestampComparisonExp `json:"event_time"`
	Score     *BigintComparisonExp    `json:"score"`
	Team      *TeamsBoolExp           `json:"team"`
	TeamID    *IntComparisonExp       `json:"team_id"`
}

// input type for incrementing numeric columns in table "score_timeline"
type ScoreTimelineIncInput struct {
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
}

// input type for inserting data into table "score_timeline"
type ScoreTimelineInsertInput struct {
	EventTime *time.Time              `json:"event_time"`
	Score     *int64                  `json:"score"`
	Team      *TeamsObjRelInsertInput `json:"team"`
	TeamID    *int64                  `json:"team_id"`
}

// aggregate max on columns
type ScoreTimelineMaxFields struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
}

// order by max() on columns of table "score_timeline"
type ScoreTimelineMaxOrderBy struct {
	EventTime *OrderBy `json:"event_time"`
	Score     *OrderBy `json:"score"`
	TeamID    *OrderBy `json:"team_id"`
}

// aggregate min on columns
type ScoreTimelineMinFields struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
}

// order by min() on columns of table "score_timeline"
type ScoreTimelineMinOrderBy struct {
	EventTime *OrderBy `json:"event_time"`
	Score     *OrderBy `json:"score"`
	TeamID    *OrderBy `json:"team_id"`
}

// response of any mutation on the table "score_timeline"
type ScoreTimelineMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*ScoreTimeline `json:"returning"`
}

// Ordering options when selecting data from "score_timeline".
type ScoreTimelineOrderBy struct {
	EventTime *OrderBy      `json:"event_time"`
	Score     *OrderBy      `json:"score"`
	Team      *TeamsOrderBy `json:"team"`
	TeamID    *OrderBy      `json:"team_id"`
}

// input type for updating data in table "score_timeline"
type ScoreTimelineSetInput struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
}

// aggregate stddev on columns
type ScoreTimelineStddevFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by stddev() on columns of table "score_timeline"
type ScoreTimelineStddevOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// aggregate stddev_pop on columns
type ScoreTimelineStddevPopFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by stddev_pop() on columns of table "score_timeline"
type ScoreTimelineStddevPopOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// aggregate stddev_samp on columns
type ScoreTimelineStddevSampFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by stddev_samp() on columns of table "score_timeline"
type ScoreTimelineStddevSampOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// aggregate sum on columns
type ScoreTimelineSumFields struct {
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
}

// order by sum() on columns of table "score_timeline"
type ScoreTimelineSumOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// columns and relationships of "score_timeline_user"
type ScoreTimelineUser struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "score_timeline_user"
type ScoreTimelineUserAggregate struct {
	Aggregate *ScoreTimelineUserAggregateFields `json:"aggregate"`
	Nodes     []*ScoreTimelineUser              `json:"nodes"`
}

// aggregate fields of "score_timeline_user"
type ScoreTimelineUserAggregateFields struct {
	Avg        *ScoreTimelineUserAvgFields        `json:"avg"`
	Count      int64                              `json:"count"`
	Max        *ScoreTimelineUserMaxFields        `json:"max"`
	Min        *ScoreTimelineUserMinFields        `json:"min"`
	Stddev     *ScoreTimelineUserStddevFields     `json:"stddev"`
	StddevPop  *ScoreTimelineUserStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ScoreTimelineUserStddevSampFields `json:"stddev_samp"`
	Sum        *ScoreTimelineUserSumFields        `json:"sum"`
	VarPop     *ScoreTimelineUserVarPopFields     `json:"var_pop"`
	VarSamp    *ScoreTimelineUserVarSampFields    `json:"var_samp"`
	Variance   *ScoreTimelineUserVarianceFields   `json:"variance"`
}

// order by aggregate values of table "score_timeline_user"
type ScoreTimelineUserAggregateOrderBy struct {
	Avg        *ScoreTimelineUserAvgOrderBy        `json:"avg"`
	Count      *OrderBy                            `json:"count"`
	Max        *ScoreTimelineUserMaxOrderBy        `json:"max"`
	Min        *ScoreTimelineUserMinOrderBy        `json:"min"`
	Stddev     *ScoreTimelineUserStddevOrderBy     `json:"stddev"`
	StddevPop  *ScoreTimelineUserStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *ScoreTimelineUserStddevSampOrderBy `json:"stddev_samp"`
	Sum        *ScoreTimelineUserSumOrderBy        `json:"sum"`
	VarPop     *ScoreTimelineUserVarPopOrderBy     `json:"var_pop"`
	VarSamp    *ScoreTimelineUserVarSampOrderBy    `json:"var_samp"`
	Variance   *ScoreTimelineUserVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "score_timeline_user"
type ScoreTimelineUserArrRelInsertInput struct {
	Data []*ScoreTimelineUserInsertInput `json:"data"`
}

// aggregate avg on columns
type ScoreTimelineUserAvgFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by avg() on columns of table "score_timeline_user"
type ScoreTimelineUserAvgOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "score_timeline_user". All fields are combined with a logical 'AND'.
type ScoreTimelineUserBoolExp struct {
	And       []*ScoreTimelineUserBoolExp `json:"_and"`
	Not       *ScoreTimelineUserBoolExp   `json:"_not"`
	Or        []*ScoreTimelineUserBoolExp `json:"_or"`
	EventTime *TimestampComparisonExp     `json:"event_time"`
	Score     *BigintComparisonExp        `json:"score"`
	Team      *TeamsBoolExp               `json:"team"`
	TeamID    *IntComparisonExp           `json:"team_id"`
	UserID    *IntComparisonExp           `json:"user_id"`
}

// input type for incrementing numeric columns in table "score_timeline_user"
type ScoreTimelineUserIncInput struct {
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "score_timeline_user"
type ScoreTimelineUserInsertInput struct {
	EventTime *time.Time              `json:"event_time"`
	Score     *int64                  `json:"score"`
	Team      *TeamsObjRelInsertInput `json:"team"`
	TeamID    *int64                  `json:"team_id"`
	UserID    *int64                  `json:"user_id"`
}

// aggregate max on columns
type ScoreTimelineUserMaxFields struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
	UserID    *int64     `json:"user_id"`
}

// order by max() on columns of table "score_timeline_user"
type ScoreTimelineUserMaxOrderBy struct {
	EventTime *OrderBy `json:"event_time"`
	Score     *OrderBy `json:"score"`
	TeamID    *OrderBy `json:"team_id"`
	UserID    *OrderBy `json:"user_id"`
}

// aggregate min on columns
type ScoreTimelineUserMinFields struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
	UserID    *int64     `json:"user_id"`
}

// order by min() on columns of table "score_timeline_user"
type ScoreTimelineUserMinOrderBy struct {
	EventTime *OrderBy `json:"event_time"`
	Score     *OrderBy `json:"score"`
	TeamID    *OrderBy `json:"team_id"`
	UserID    *OrderBy `json:"user_id"`
}

// response of any mutation on the table "score_timeline_user"
type ScoreTimelineUserMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*ScoreTimelineUser `json:"returning"`
}

// Ordering options when selecting data from "score_timeline_user".
type ScoreTimelineUserOrderBy struct {
	EventTime *OrderBy      `json:"event_time"`
	Score     *OrderBy      `json:"score"`
	Team      *TeamsOrderBy `json:"team"`
	TeamID    *OrderBy      `json:"team_id"`
	UserID    *OrderBy      `json:"user_id"`
}

// input type for updating data in table "score_timeline_user"
type ScoreTimelineUserSetInput struct {
	EventTime *time.Time `json:"event_time"`
	Score     *int64     `json:"score"`
	TeamID    *int64     `json:"team_id"`
	UserID    *int64     `json:"user_id"`
}

// aggregate stddev on columns
type ScoreTimelineUserStddevFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev() on columns of table "score_timeline_user"
type ScoreTimelineUserStddevOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type ScoreTimelineUserStddevPopFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "score_timeline_user"
type ScoreTimelineUserStddevPopOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type ScoreTimelineUserStddevSampFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "score_timeline_user"
type ScoreTimelineUserStddevSampOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type ScoreTimelineUserSumFields struct {
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// order by sum() on columns of table "score_timeline_user"
type ScoreTimelineUserSumOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type ScoreTimelineUserVarPopFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "score_timeline_user"
type ScoreTimelineUserVarPopOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type ScoreTimelineUserVarSampFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "score_timeline_user"
type ScoreTimelineUserVarSampOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type ScoreTimelineUserVarianceFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by variance() on columns of table "score_timeline_user"
type ScoreTimelineUserVarianceOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type ScoreTimelineVarPopFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by var_pop() on columns of table "score_timeline"
type ScoreTimelineVarPopOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// aggregate var_samp on columns
type ScoreTimelineVarSampFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by var_samp() on columns of table "score_timeline"
type ScoreTimelineVarSampOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// aggregate variance on columns
type ScoreTimelineVarianceFields struct {
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// order by variance() on columns of table "score_timeline"
type ScoreTimelineVarianceOrderBy struct {
	Score  *OrderBy `json:"score"`
	TeamID *OrderBy `json:"team_id"`
}

// columns and relationships of "scoreboard"
type Scoreboard struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
}

// aggregated selection of "scoreboard"
type ScoreboardAggregate struct {
	Aggregate *ScoreboardAggregateFields `json:"aggregate"`
	Nodes     []*Scoreboard              `json:"nodes"`
}

// aggregate fields of "scoreboard"
type ScoreboardAggregateFields struct {
	Avg        *ScoreboardAvgFields        `json:"avg"`
	Count      int64                       `json:"count"`
	Max        *ScoreboardMaxFields        `json:"max"`
	Min        *ScoreboardMinFields        `json:"min"`
	Stddev     *ScoreboardStddevFields     `json:"stddev"`
	StddevPop  *ScoreboardStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ScoreboardStddevSampFields `json:"stddev_samp"`
	Sum        *ScoreboardSumFields        `json:"sum"`
	VarPop     *ScoreboardVarPopFields     `json:"var_pop"`
	VarSamp    *ScoreboardVarSampFields    `json:"var_samp"`
	Variance   *ScoreboardVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type ScoreboardAvgFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// Boolean expression to filter rows from the table "scoreboard". All fields are combined with a logical 'AND'.
type ScoreboardBoolExp struct {
	And     []*ScoreboardBoolExp    `json:"_and"`
	Not     *ScoreboardBoolExp      `json:"_not"`
	Or      []*ScoreboardBoolExp    `json:"_or"`
	MaxTime *TimestampComparisonExp `json:"max_time"`
	Rank    *BigintComparisonExp    `json:"rank"`
	Score   *BigintComparisonExp    `json:"score"`
	Team    *TeamsBoolExp           `json:"team"`
	TeamID  *IntComparisonExp       `json:"team_id"`
}

// input type for incrementing numeric columns in table "scoreboard"
type ScoreboardIncInput struct {
	Rank   *int64 `json:"rank"`
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
}

// input type for inserting data into table "scoreboard"
type ScoreboardInsertInput struct {
	MaxTime *time.Time              `json:"max_time"`
	Rank    *int64                  `json:"rank"`
	Score   *int64                  `json:"score"`
	Team    *TeamsObjRelInsertInput `json:"team"`
	TeamID  *int64                  `json:"team_id"`
}

// aggregate max on columns
type ScoreboardMaxFields struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
}

// aggregate min on columns
type ScoreboardMinFields struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
}

// response of any mutation on the table "scoreboard"
type ScoreboardMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Scoreboard `json:"returning"`
}

// Ordering options when selecting data from "scoreboard".
type ScoreboardOrderBy struct {
	MaxTime *OrderBy      `json:"max_time"`
	Rank    *OrderBy      `json:"rank"`
	Score   *OrderBy      `json:"score"`
	Team    *TeamsOrderBy `json:"team"`
	TeamID  *OrderBy      `json:"team_id"`
}

// input type for updating data in table "scoreboard"
type ScoreboardSetInput struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
}

// aggregate stddev on columns
type ScoreboardStddevFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// aggregate stddev_pop on columns
type ScoreboardStddevPopFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// aggregate stddev_samp on columns
type ScoreboardStddevSampFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// aggregate sum on columns
type ScoreboardSumFields struct {
	Rank   *int64 `json:"rank"`
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
}

// columns and relationships of "scoreboard_user"
type ScoreboardUser struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "scoreboard_user"
type ScoreboardUserAggregate struct {
	Aggregate *ScoreboardUserAggregateFields `json:"aggregate"`
	Nodes     []*ScoreboardUser              `json:"nodes"`
}

// aggregate fields of "scoreboard_user"
type ScoreboardUserAggregateFields struct {
	Avg        *ScoreboardUserAvgFields        `json:"avg"`
	Count      int64                           `json:"count"`
	Max        *ScoreboardUserMaxFields        `json:"max"`
	Min        *ScoreboardUserMinFields        `json:"min"`
	Stddev     *ScoreboardUserStddevFields     `json:"stddev"`
	StddevPop  *ScoreboardUserStddevPopFields  `json:"stddev_pop"`
	StddevSamp *ScoreboardUserStddevSampFields `json:"stddev_samp"`
	Sum        *ScoreboardUserSumFields        `json:"sum"`
	VarPop     *ScoreboardUserVarPopFields     `json:"var_pop"`
	VarSamp    *ScoreboardUserVarSampFields    `json:"var_samp"`
	Variance   *ScoreboardUserVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type ScoreboardUserAvgFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// Boolean expression to filter rows from the table "scoreboard_user". All fields are combined with a logical 'AND'.
type ScoreboardUserBoolExp struct {
	And     []*ScoreboardUserBoolExp `json:"_and"`
	Not     *ScoreboardUserBoolExp   `json:"_not"`
	Or      []*ScoreboardUserBoolExp `json:"_or"`
	MaxTime *TimestampComparisonExp  `json:"max_time"`
	Rank    *BigintComparisonExp     `json:"rank"`
	Score   *BigintComparisonExp     `json:"score"`
	Team    *TeamsBoolExp            `json:"team"`
	TeamID  *IntComparisonExp        `json:"team_id"`
	User    *UsersBoolExp            `json:"user"`
	UserID  *IntComparisonExp        `json:"user_id"`
}

// input type for incrementing numeric columns in table "scoreboard_user"
type ScoreboardUserIncInput struct {
	Rank   *int64 `json:"rank"`
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "scoreboard_user"
type ScoreboardUserInsertInput struct {
	MaxTime *time.Time              `json:"max_time"`
	Rank    *int64                  `json:"rank"`
	Score   *int64                  `json:"score"`
	Team    *TeamsObjRelInsertInput `json:"team"`
	TeamID  *int64                  `json:"team_id"`
	User    *UsersObjRelInsertInput `json:"user"`
	UserID  *int64                  `json:"user_id"`
}

// aggregate max on columns
type ScoreboardUserMaxFields struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
	UserID  *int64     `json:"user_id"`
}

// aggregate min on columns
type ScoreboardUserMinFields struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
	UserID  *int64     `json:"user_id"`
}

// response of any mutation on the table "scoreboard_user"
type ScoreboardUserMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*ScoreboardUser `json:"returning"`
}

// Ordering options when selecting data from "scoreboard_user".
type ScoreboardUserOrderBy struct {
	MaxTime *OrderBy      `json:"max_time"`
	Rank    *OrderBy      `json:"rank"`
	Score   *OrderBy      `json:"score"`
	Team    *TeamsOrderBy `json:"team"`
	TeamID  *OrderBy      `json:"team_id"`
	User    *UsersOrderBy `json:"user"`
	UserID  *OrderBy      `json:"user_id"`
}

// input type for updating data in table "scoreboard_user"
type ScoreboardUserSetInput struct {
	MaxTime *time.Time `json:"max_time"`
	Rank    *int64     `json:"rank"`
	Score   *int64     `json:"score"`
	TeamID  *int64     `json:"team_id"`
	UserID  *int64     `json:"user_id"`
}

// aggregate stddev on columns
type ScoreboardUserStddevFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate stddev_pop on columns
type ScoreboardUserStddevPopFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate stddev_samp on columns
type ScoreboardUserStddevSampFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate sum on columns
type ScoreboardUserSumFields struct {
	Rank   *int64 `json:"rank"`
	Score  *int64 `json:"score"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// aggregate var_pop on columns
type ScoreboardUserVarPopFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate var_samp on columns
type ScoreboardUserVarSampFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate variance on columns
type ScoreboardUserVarianceFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// aggregate var_pop on columns
type ScoreboardVarPopFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// aggregate var_samp on columns
type ScoreboardVarSampFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// aggregate variance on columns
type ScoreboardVarianceFields struct {
	Rank   *float64 `json:"rank"`
	Score  *float64 `json:"score"`
	TeamID *float64 `json:"team_id"`
}

// columns and relationships of "solves"
type Solves struct {
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	ID          int64       `json:"id"`
	// An object relationship
	Submission *Submissions `json:"submission"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "solves"
type SolvesAggregate struct {
	Aggregate *SolvesAggregateFields `json:"aggregate"`
	Nodes     []*Solves              `json:"nodes"`
}

// aggregate fields of "solves"
type SolvesAggregateFields struct {
	Avg        *SolvesAvgFields        `json:"avg"`
	Count      int64                   `json:"count"`
	Max        *SolvesMaxFields        `json:"max"`
	Min        *SolvesMinFields        `json:"min"`
	Stddev     *SolvesStddevFields     `json:"stddev"`
	StddevPop  *SolvesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *SolvesStddevSampFields `json:"stddev_samp"`
	Sum        *SolvesSumFields        `json:"sum"`
	VarPop     *SolvesVarPopFields     `json:"var_pop"`
	VarSamp    *SolvesVarSampFields    `json:"var_samp"`
	Variance   *SolvesVarianceFields   `json:"variance"`
}

// order by aggregate values of table "solves"
type SolvesAggregateOrderBy struct {
	Avg        *SolvesAvgOrderBy        `json:"avg"`
	Count      *OrderBy                 `json:"count"`
	Max        *SolvesMaxOrderBy        `json:"max"`
	Min        *SolvesMinOrderBy        `json:"min"`
	Stddev     *SolvesStddevOrderBy     `json:"stddev"`
	StddevPop  *SolvesStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *SolvesStddevSampOrderBy `json:"stddev_samp"`
	Sum        *SolvesSumOrderBy        `json:"sum"`
	VarPop     *SolvesVarPopOrderBy     `json:"var_pop"`
	VarSamp    *SolvesVarSampOrderBy    `json:"var_samp"`
	Variance   *SolvesVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "solves"
type SolvesArrRelInsertInput struct {
	Data []*SolvesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *SolvesOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type SolvesAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by avg() on columns of table "solves"
type SolvesAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "solves". All fields are combined with a logical 'AND'.
type SolvesBoolExp struct {
	And         []*SolvesBoolExp    `json:"_and"`
	Not         *SolvesBoolExp      `json:"_not"`
	Or          []*SolvesBoolExp    `json:"_or"`
	Challenge   *ChallengesBoolExp  `json:"challenge"`
	ChallengeID *IntComparisonExp   `json:"challenge_id"`
	ID          *IntComparisonExp   `json:"id"`
	Submission  *SubmissionsBoolExp `json:"submission"`
	Team        *TeamsBoolExp       `json:"team"`
	TeamID      *IntComparisonExp   `json:"team_id"`
	User        *UsersBoolExp       `json:"user"`
	UserID      *IntComparisonExp   `json:"user_id"`
}

// input type for incrementing numeric columns in table "solves"
type SolvesIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// input type for inserting data into table "solves"
type SolvesInsertInput struct {
	Challenge   *ChallengesObjRelInsertInput  `json:"challenge"`
	ChallengeID *int64                        `json:"challenge_id"`
	ID          *int64                        `json:"id"`
	Submission  *SubmissionsObjRelInsertInput `json:"submission"`
	Team        *TeamsObjRelInsertInput       `json:"team"`
	TeamID      *int64                        `json:"team_id"`
	User        *UsersObjRelInsertInput       `json:"user"`
	UserID      *int64                        `json:"user_id"`
}

// aggregate max on columns
type SolvesMaxFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// order by max() on columns of table "solves"
type SolvesMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate min on columns
type SolvesMinFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// order by min() on columns of table "solves"
type SolvesMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// response of any mutation on the table "solves"
type SolvesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Solves `json:"returning"`
}

// input type for inserting object relation for remote table "solves"
type SolvesObjRelInsertInput struct {
	Data *SolvesInsertInput `json:"data"`
	// on conflict condition
	OnConflict *SolvesOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "solves"
type SolvesOnConflict struct {
	Constraint    SolvesConstraint     `json:"constraint"`
	UpdateColumns []SolvesUpdateColumn `json:"update_columns"`
	Where         *SolvesBoolExp       `json:"where"`
}

// Ordering options when selecting data from "solves".
type SolvesOrderBy struct {
	Challenge   *ChallengesOrderBy  `json:"challenge"`
	ChallengeID *OrderBy            `json:"challenge_id"`
	ID          *OrderBy            `json:"id"`
	Submission  *SubmissionsOrderBy `json:"submission"`
	Team        *TeamsOrderBy       `json:"team"`
	TeamID      *OrderBy            `json:"team_id"`
	User        *UsersOrderBy       `json:"user"`
	UserID      *OrderBy            `json:"user_id"`
}

// primary key columns input for table: solves
type SolvesPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "solves"
type SolvesSetInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// aggregate stddev on columns
type SolvesStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev() on columns of table "solves"
type SolvesStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type SolvesStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "solves"
type SolvesStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type SolvesStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "solves"
type SolvesStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type SolvesSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// order by sum() on columns of table "solves"
type SolvesSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type SolvesVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "solves"
type SolvesVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type SolvesVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "solves"
type SolvesVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type SolvesVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by variance() on columns of table "solves"
type SolvesVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// columns and relationships of "submissions"
type Submissions struct {
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	Date        *time.Time  `json:"date"`
	ID          int64       `json:"id"`
	IP          *string     `json:"ip"`
	Provided    *string     `json:"provided"`
	// An object relationship
	Solve *Solves `json:"solve"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Type   *string `json:"type"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "submissions"
type SubmissionsAggregate struct {
	Aggregate *SubmissionsAggregateFields `json:"aggregate"`
	Nodes     []*Submissions              `json:"nodes"`
}

// aggregate fields of "submissions"
type SubmissionsAggregateFields struct {
	Avg        *SubmissionsAvgFields        `json:"avg"`
	Count      int64                        `json:"count"`
	Max        *SubmissionsMaxFields        `json:"max"`
	Min        *SubmissionsMinFields        `json:"min"`
	Stddev     *SubmissionsStddevFields     `json:"stddev"`
	StddevPop  *SubmissionsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *SubmissionsStddevSampFields `json:"stddev_samp"`
	Sum        *SubmissionsSumFields        `json:"sum"`
	VarPop     *SubmissionsVarPopFields     `json:"var_pop"`
	VarSamp    *SubmissionsVarSampFields    `json:"var_samp"`
	Variance   *SubmissionsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "submissions"
type SubmissionsAggregateOrderBy struct {
	Avg        *SubmissionsAvgOrderBy        `json:"avg"`
	Count      *OrderBy                      `json:"count"`
	Max        *SubmissionsMaxOrderBy        `json:"max"`
	Min        *SubmissionsMinOrderBy        `json:"min"`
	Stddev     *SubmissionsStddevOrderBy     `json:"stddev"`
	StddevPop  *SubmissionsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *SubmissionsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *SubmissionsSumOrderBy        `json:"sum"`
	VarPop     *SubmissionsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *SubmissionsVarSampOrderBy    `json:"var_samp"`
	Variance   *SubmissionsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "submissions"
type SubmissionsArrRelInsertInput struct {
	Data []*SubmissionsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *SubmissionsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type SubmissionsAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by avg() on columns of table "submissions"
type SubmissionsAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "submissions". All fields are combined with a logical 'AND'.
type SubmissionsBoolExp struct {
	And         []*SubmissionsBoolExp   `json:"_and"`
	Not         *SubmissionsBoolExp     `json:"_not"`
	Or          []*SubmissionsBoolExp   `json:"_or"`
	Challenge   *ChallengesBoolExp      `json:"challenge"`
	ChallengeID *IntComparisonExp       `json:"challenge_id"`
	Date        *TimestampComparisonExp `json:"date"`
	ID          *IntComparisonExp       `json:"id"`
	IP          *StringComparisonExp    `json:"ip"`
	Provided    *StringComparisonExp    `json:"provided"`
	Solve       *SolvesBoolExp          `json:"solve"`
	Team        *TeamsBoolExp           `json:"team"`
	TeamID      *IntComparisonExp       `json:"team_id"`
	Type        *StringComparisonExp    `json:"type"`
	User        *UsersBoolExp           `json:"user"`
	UserID      *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "submissions"
type SubmissionsIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// input type for inserting data into table "submissions"
type SubmissionsInsertInput struct {
	Challenge   *ChallengesObjRelInsertInput `json:"challenge"`
	ChallengeID *int64                       `json:"challenge_id"`
	Date        *time.Time                   `json:"date"`
	ID          *int64                       `json:"id"`
	IP          *string                      `json:"ip"`
	Provided    *string                      `json:"provided"`
	Solve       *SolvesObjRelInsertInput     `json:"solve"`
	Team        *TeamsObjRelInsertInput      `json:"team"`
	TeamID      *int64                       `json:"team_id"`
	Type        *string                      `json:"type"`
	User        *UsersObjRelInsertInput      `json:"user"`
	UserID      *int64                       `json:"user_id"`
}

// aggregate max on columns
type SubmissionsMaxFields struct {
	ChallengeID *int64     `json:"challenge_id"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	IP          *string    `json:"ip"`
	Provided    *string    `json:"provided"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// order by max() on columns of table "submissions"
type SubmissionsMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Date        *OrderBy `json:"date"`
	ID          *OrderBy `json:"id"`
	IP          *OrderBy `json:"ip"`
	Provided    *OrderBy `json:"provided"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate min on columns
type SubmissionsMinFields struct {
	ChallengeID *int64     `json:"challenge_id"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	IP          *string    `json:"ip"`
	Provided    *string    `json:"provided"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// order by min() on columns of table "submissions"
type SubmissionsMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	Date        *OrderBy `json:"date"`
	ID          *OrderBy `json:"id"`
	IP          *OrderBy `json:"ip"`
	Provided    *OrderBy `json:"provided"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	UserID      *OrderBy `json:"user_id"`
}

// response of any mutation on the table "submissions"
type SubmissionsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Submissions `json:"returning"`
}

// input type for inserting object relation for remote table "submissions"
type SubmissionsObjRelInsertInput struct {
	Data *SubmissionsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *SubmissionsOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "submissions"
type SubmissionsOnConflict struct {
	Constraint    SubmissionsConstraint     `json:"constraint"`
	UpdateColumns []SubmissionsUpdateColumn `json:"update_columns"`
	Where         *SubmissionsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "submissions".
type SubmissionsOrderBy struct {
	Challenge   *ChallengesOrderBy `json:"challenge"`
	ChallengeID *OrderBy           `json:"challenge_id"`
	Date        *OrderBy           `json:"date"`
	ID          *OrderBy           `json:"id"`
	IP          *OrderBy           `json:"ip"`
	Provided    *OrderBy           `json:"provided"`
	Solve       *SolvesOrderBy     `json:"solve"`
	Team        *TeamsOrderBy      `json:"team"`
	TeamID      *OrderBy           `json:"team_id"`
	Type        *OrderBy           `json:"type"`
	User        *UsersOrderBy      `json:"user"`
	UserID      *OrderBy           `json:"user_id"`
}

// primary key columns input for table: submissions
type SubmissionsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "submissions"
type SubmissionsSetInput struct {
	ChallengeID *int64     `json:"challenge_id"`
	Date        *time.Time `json:"date"`
	ID          *int64     `json:"id"`
	IP          *string    `json:"ip"`
	Provided    *string    `json:"provided"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	UserID      *int64     `json:"user_id"`
}

// aggregate stddev on columns
type SubmissionsStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev() on columns of table "submissions"
type SubmissionsStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type SubmissionsStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "submissions"
type SubmissionsStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type SubmissionsStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "submissions"
type SubmissionsStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type SubmissionsSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
	TeamID      *int64 `json:"team_id"`
	UserID      *int64 `json:"user_id"`
}

// order by sum() on columns of table "submissions"
type SubmissionsSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type SubmissionsVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "submissions"
type SubmissionsVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type SubmissionsVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "submissions"
type SubmissionsVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type SubmissionsVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
	TeamID      *float64 `json:"team_id"`
	UserID      *float64 `json:"user_id"`
}

// order by variance() on columns of table "submissions"
type SubmissionsVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	TeamID      *OrderBy `json:"team_id"`
	UserID      *OrderBy `json:"user_id"`
}

// columns and relationships of "tags"
type Tags struct {
	// An object relationship
	Challenge   *Challenges `json:"challenge"`
	ChallengeID *int64      `json:"challenge_id"`
	ID          int64       `json:"id"`
	Value       *string     `json:"value"`
}

// aggregated selection of "tags"
type TagsAggregate struct {
	Aggregate *TagsAggregateFields `json:"aggregate"`
	Nodes     []*Tags              `json:"nodes"`
}

// aggregate fields of "tags"
type TagsAggregateFields struct {
	Avg        *TagsAvgFields        `json:"avg"`
	Count      int64                 `json:"count"`
	Max        *TagsMaxFields        `json:"max"`
	Min        *TagsMinFields        `json:"min"`
	Stddev     *TagsStddevFields     `json:"stddev"`
	StddevPop  *TagsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TagsStddevSampFields `json:"stddev_samp"`
	Sum        *TagsSumFields        `json:"sum"`
	VarPop     *TagsVarPopFields     `json:"var_pop"`
	VarSamp    *TagsVarSampFields    `json:"var_samp"`
	Variance   *TagsVarianceFields   `json:"variance"`
}

// order by aggregate values of table "tags"
type TagsAggregateOrderBy struct {
	Avg        *TagsAvgOrderBy        `json:"avg"`
	Count      *OrderBy               `json:"count"`
	Max        *TagsMaxOrderBy        `json:"max"`
	Min        *TagsMinOrderBy        `json:"min"`
	Stddev     *TagsStddevOrderBy     `json:"stddev"`
	StddevPop  *TagsStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TagsStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TagsSumOrderBy        `json:"sum"`
	VarPop     *TagsVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TagsVarSampOrderBy    `json:"var_samp"`
	Variance   *TagsVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "tags"
type TagsArrRelInsertInput struct {
	Data []*TagsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *TagsOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type TagsAvgFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by avg() on columns of table "tags"
type TagsAvgOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
type TagsBoolExp struct {
	And         []*TagsBoolExp       `json:"_and"`
	Not         *TagsBoolExp         `json:"_not"`
	Or          []*TagsBoolExp       `json:"_or"`
	Challenge   *ChallengesBoolExp   `json:"challenge"`
	ChallengeID *IntComparisonExp    `json:"challenge_id"`
	ID          *IntComparisonExp    `json:"id"`
	Value       *StringComparisonExp `json:"value"`
}

// input type for incrementing numeric columns in table "tags"
type TagsIncInput struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
}

// input type for inserting data into table "tags"
type TagsInsertInput struct {
	Challenge   *ChallengesObjRelInsertInput `json:"challenge"`
	ChallengeID *int64                       `json:"challenge_id"`
	ID          *int64                       `json:"id"`
	Value       *string                      `json:"value"`
}

// aggregate max on columns
type TagsMaxFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Value       *string `json:"value"`
}

// order by max() on columns of table "tags"
type TagsMaxOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	Value       *OrderBy `json:"value"`
}

// aggregate min on columns
type TagsMinFields struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Value       *string `json:"value"`
}

// order by min() on columns of table "tags"
type TagsMinOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
	Value       *OrderBy `json:"value"`
}

// response of any mutation on the table "tags"
type TagsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Tags `json:"returning"`
}

// on conflict condition type for table "tags"
type TagsOnConflict struct {
	Constraint    TagsConstraint     `json:"constraint"`
	UpdateColumns []TagsUpdateColumn `json:"update_columns"`
	Where         *TagsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "tags".
type TagsOrderBy struct {
	Challenge   *ChallengesOrderBy `json:"challenge"`
	ChallengeID *OrderBy           `json:"challenge_id"`
	ID          *OrderBy           `json:"id"`
	Value       *OrderBy           `json:"value"`
}

// primary key columns input for table: tags
type TagsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "tags"
type TagsSetInput struct {
	ChallengeID *int64  `json:"challenge_id"`
	ID          *int64  `json:"id"`
	Value       *string `json:"value"`
}

// aggregate stddev on columns
type TagsStddevFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev() on columns of table "tags"
type TagsStddevOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type TagsStddevPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "tags"
type TagsStddevPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type TagsStddevSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "tags"
type TagsStddevSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate sum on columns
type TagsSumFields struct {
	ChallengeID *int64 `json:"challenge_id"`
	ID          *int64 `json:"id"`
}

// order by sum() on columns of table "tags"
type TagsSumOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_pop on columns
type TagsVarPopFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by var_pop() on columns of table "tags"
type TagsVarPopOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate var_samp on columns
type TagsVarSampFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by var_samp() on columns of table "tags"
type TagsVarSampOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// aggregate variance on columns
type TagsVarianceFields struct {
	ChallengeID *float64 `json:"challenge_id"`
	ID          *float64 `json:"id"`
}

// order by variance() on columns of table "tags"
type TagsVarianceOrderBy struct {
	ChallengeID *OrderBy `json:"challenge_id"`
	ID          *OrderBy `json:"id"`
}

// columns and relationships of "teams"
type Teams struct {
	Affiliation *string `json:"affiliation"`
	// An array relationship
	Awards []*Awards `json:"awards"`
	// An aggregate relationship
	AwardsAggregate *AwardsAggregate `json:"awards_aggregate"`
	Banned          *bool            `json:"banned"`
	Bracket         *string          `json:"bracket"`
	// An object relationship
	Captain   *Users `json:"captain"`
	CaptainID *int64 `json:"captain_id"`
	// An array relationship
	Comments []*Comments `json:"comments"`
	// An aggregate relationship
	CommentsAggregate *CommentsAggregate `json:"comments_aggregate"`
	Country           *string            `json:"country"`
	Created           *time.Time         `json:"created"`
	Email             *string            `json:"email"`
	// An array relationship
	FieldEntries []*FieldEntries `json:"field_entries"`
	// An aggregate relationship
	FieldEntriesAggregate *FieldEntriesAggregate `json:"field_entries_aggregate"`
	Hidden                *bool                  `json:"hidden"`
	ID                    int64                  `json:"id"`
	// An array relationship
	Members []*Users `json:"members"`
	// An aggregate relationship
	MembersAggregate *UsersAggregate `json:"members_aggregate"`
	Name             *string         `json:"name"`
	OauthID          *int64          `json:"oauth_id"`
	Password         *string         `json:"password"`
	// A computed field, executes function "team_score"
	Score *int64 `json:"score"`
	// An array relationship
	ScoreTimeline []*ScoreTimeline `json:"score_timeline"`
	// An aggregate relationship
	ScoreTimelineAggregate *ScoreTimelineAggregate `json:"score_timeline_aggregate"`
	Secret                 *string                 `json:"secret"`
	// An array relationship
	Solves []*Solves `json:"solves"`
	// An aggregate relationship
	SolvesAggregate *SolvesAggregate `json:"solves_aggregate"`
	// An array relationship
	Submissions []*Submissions `json:"submissions"`
	// An aggregate relationship
	SubmissionsAggregate *SubmissionsAggregate `json:"submissions_aggregate"`
	// An array relationship
	Unlocks []*Unlocks `json:"unlocks"`
	// An aggregate relationship
	UnlocksAggregate *UnlocksAggregate `json:"unlocks_aggregate"`
	Website          *string           `json:"website"`
}

// aggregated selection of "teams"
type TeamsAggregate struct {
	Aggregate *TeamsAggregateFields `json:"aggregate"`
	Nodes     []*Teams              `json:"nodes"`
}

// aggregate fields of "teams"
type TeamsAggregateFields struct {
	Avg        *TeamsAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *TeamsMaxFields        `json:"max"`
	Min        *TeamsMinFields        `json:"min"`
	Stddev     *TeamsStddevFields     `json:"stddev"`
	StddevPop  *TeamsStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TeamsStddevSampFields `json:"stddev_samp"`
	Sum        *TeamsSumFields        `json:"sum"`
	VarPop     *TeamsVarPopFields     `json:"var_pop"`
	VarSamp    *TeamsVarSampFields    `json:"var_samp"`
	Variance   *TeamsVarianceFields   `json:"variance"`
}

// aggregate avg on columns
type TeamsAvgFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// Boolean expression to filter rows from the table "teams". All fields are combined with a logical 'AND'.
type TeamsBoolExp struct {
	And           []*TeamsBoolExp         `json:"_and"`
	Not           *TeamsBoolExp           `json:"_not"`
	Or            []*TeamsBoolExp         `json:"_or"`
	Affiliation   *StringComparisonExp    `json:"affiliation"`
	Awards        *AwardsBoolExp          `json:"awards"`
	Banned        *BooleanComparisonExp   `json:"banned"`
	Bracket       *StringComparisonExp    `json:"bracket"`
	Captain       *UsersBoolExp           `json:"captain"`
	CaptainID     *IntComparisonExp       `json:"captain_id"`
	Comments      *CommentsBoolExp        `json:"comments"`
	Country       *StringComparisonExp    `json:"country"`
	Created       *TimestampComparisonExp `json:"created"`
	Email         *StringComparisonExp    `json:"email"`
	FieldEntries  *FieldEntriesBoolExp    `json:"field_entries"`
	Hidden        *BooleanComparisonExp   `json:"hidden"`
	ID            *IntComparisonExp       `json:"id"`
	Members       *UsersBoolExp           `json:"members"`
	Name          *StringComparisonExp    `json:"name"`
	OauthID       *IntComparisonExp       `json:"oauth_id"`
	Password      *StringComparisonExp    `json:"password"`
	ScoreTimeline *ScoreTimelineBoolExp   `json:"score_timeline"`
	Secret        *StringComparisonExp    `json:"secret"`
	Solves        *SolvesBoolExp          `json:"solves"`
	Submissions   *SubmissionsBoolExp     `json:"submissions"`
	Unlocks       *UnlocksBoolExp         `json:"unlocks"`
	Website       *StringComparisonExp    `json:"website"`
}

// input type for incrementing numeric columns in table "teams"
type TeamsIncInput struct {
	CaptainID *int64 `json:"captain_id"`
	ID        *int64 `json:"id"`
	OauthID   *int64 `json:"oauth_id"`
}

// input type for inserting data into table "teams"
type TeamsInsertInput struct {
	Affiliation   *string                         `json:"affiliation"`
	Awards        *AwardsArrRelInsertInput        `json:"awards"`
	Banned        *bool                           `json:"banned"`
	Bracket       *string                         `json:"bracket"`
	Captain       *UsersObjRelInsertInput         `json:"captain"`
	CaptainID     *int64                          `json:"captain_id"`
	Comments      *CommentsArrRelInsertInput      `json:"comments"`
	Country       *string                         `json:"country"`
	Created       *time.Time                      `json:"created"`
	Email         *string                         `json:"email"`
	FieldEntries  *FieldEntriesArrRelInsertInput  `json:"field_entries"`
	Hidden        *bool                           `json:"hidden"`
	ID            *int64                          `json:"id"`
	Members       *UsersArrRelInsertInput         `json:"members"`
	Name          *string                         `json:"name"`
	OauthID       *int64                          `json:"oauth_id"`
	Password      *string                         `json:"password"`
	ScoreTimeline *ScoreTimelineArrRelInsertInput `json:"score_timeline"`
	Secret        *string                         `json:"secret"`
	Solves        *SolvesArrRelInsertInput        `json:"solves"`
	Submissions   *SubmissionsArrRelInsertInput   `json:"submissions"`
	Unlocks       *UnlocksArrRelInsertInput       `json:"unlocks"`
	Website       *string                         `json:"website"`
}

// aggregate max on columns
type TeamsMaxFields struct {
	Affiliation *string    `json:"affiliation"`
	Bracket     *string    `json:"bracket"`
	CaptainID   *int64     `json:"captain_id"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	Website     *string    `json:"website"`
}

// aggregate min on columns
type TeamsMinFields struct {
	Affiliation *string    `json:"affiliation"`
	Bracket     *string    `json:"bracket"`
	CaptainID   *int64     `json:"captain_id"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	Website     *string    `json:"website"`
}

// response of any mutation on the table "teams"
type TeamsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Teams `json:"returning"`
}

// input type for inserting object relation for remote table "teams"
type TeamsObjRelInsertInput struct {
	Data *TeamsInsertInput `json:"data"`
	// on conflict condition
	OnConflict *TeamsOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "teams"
type TeamsOnConflict struct {
	Constraint    TeamsConstraint     `json:"constraint"`
	UpdateColumns []TeamsUpdateColumn `json:"update_columns"`
	Where         *TeamsBoolExp       `json:"where"`
}

// Ordering options when selecting data from "teams".
type TeamsOrderBy struct {
	Affiliation            *OrderBy                       `json:"affiliation"`
	AwardsAggregate        *AwardsAggregateOrderBy        `json:"awards_aggregate"`
	Banned                 *OrderBy                       `json:"banned"`
	Bracket                *OrderBy                       `json:"bracket"`
	Captain                *UsersOrderBy                  `json:"captain"`
	CaptainID              *OrderBy                       `json:"captain_id"`
	CommentsAggregate      *CommentsAggregateOrderBy      `json:"comments_aggregate"`
	Country                *OrderBy                       `json:"country"`
	Created                *OrderBy                       `json:"created"`
	Email                  *OrderBy                       `json:"email"`
	FieldEntriesAggregate  *FieldEntriesAggregateOrderBy  `json:"field_entries_aggregate"`
	Hidden                 *OrderBy                       `json:"hidden"`
	ID                     *OrderBy                       `json:"id"`
	MembersAggregate       *UsersAggregateOrderBy         `json:"members_aggregate"`
	Name                   *OrderBy                       `json:"name"`
	OauthID                *OrderBy                       `json:"oauth_id"`
	Password               *OrderBy                       `json:"password"`
	ScoreTimelineAggregate *ScoreTimelineAggregateOrderBy `json:"score_timeline_aggregate"`
	Secret                 *OrderBy                       `json:"secret"`
	SolvesAggregate        *SolvesAggregateOrderBy        `json:"solves_aggregate"`
	SubmissionsAggregate   *SubmissionsAggregateOrderBy   `json:"submissions_aggregate"`
	UnlocksAggregate       *UnlocksAggregateOrderBy       `json:"unlocks_aggregate"`
	Website                *OrderBy                       `json:"website"`
}

// primary key columns input for table: teams
type TeamsPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "teams"
type TeamsSetInput struct {
	Affiliation *string    `json:"affiliation"`
	Banned      *bool      `json:"banned"`
	Bracket     *string    `json:"bracket"`
	CaptainID   *int64     `json:"captain_id"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	Hidden      *bool      `json:"hidden"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	Website     *string    `json:"website"`
}

// aggregate stddev on columns
type TeamsStddevFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// aggregate stddev_pop on columns
type TeamsStddevPopFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// aggregate stddev_samp on columns
type TeamsStddevSampFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// aggregate sum on columns
type TeamsSumFields struct {
	CaptainID *int64 `json:"captain_id"`
	ID        *int64 `json:"id"`
	OauthID   *int64 `json:"oauth_id"`
}

// aggregate var_pop on columns
type TeamsVarPopFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// aggregate var_samp on columns
type TeamsVarSampFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// aggregate variance on columns
type TeamsVarianceFields struct {
	CaptainID *float64 `json:"captain_id"`
	ID        *float64 `json:"id"`
	OauthID   *float64 `json:"oauth_id"`
}

// Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
type TimestampComparisonExp struct {
	Eq     *time.Time   `json:"_eq"`
	Gt     *time.Time   `json:"_gt"`
	Gte    *time.Time   `json:"_gte"`
	In     []*time.Time `json:"_in"`
	IsNull *bool        `json:"_is_null"`
	Lt     *time.Time   `json:"_lt"`
	Lte    *time.Time   `json:"_lte"`
	Neq    *time.Time   `json:"_neq"`
	Nin    []*time.Time `json:"_nin"`
}

// columns and relationships of "tokens"
type Tokens struct {
	Created    *time.Time `json:"created"`
	Expiration *time.Time `json:"expiration"`
	ID         int64      `json:"id"`
	Type       *string    `json:"type"`
	// An object relationship
	User   *Users  `json:"user"`
	UserID *int64  `json:"user_id"`
	Value  *string `json:"value"`
}

// aggregated selection of "tokens"
type TokensAggregate struct {
	Aggregate *TokensAggregateFields `json:"aggregate"`
	Nodes     []*Tokens              `json:"nodes"`
}

// aggregate fields of "tokens"
type TokensAggregateFields struct {
	Avg        *TokensAvgFields        `json:"avg"`
	Count      int64                   `json:"count"`
	Max        *TokensMaxFields        `json:"max"`
	Min        *TokensMinFields        `json:"min"`
	Stddev     *TokensStddevFields     `json:"stddev"`
	StddevPop  *TokensStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TokensStddevSampFields `json:"stddev_samp"`
	Sum        *TokensSumFields        `json:"sum"`
	VarPop     *TokensVarPopFields     `json:"var_pop"`
	VarSamp    *TokensVarSampFields    `json:"var_samp"`
	Variance   *TokensVarianceFields   `json:"variance"`
}

// order by aggregate values of table "tokens"
type TokensAggregateOrderBy struct {
	Avg        *TokensAvgOrderBy        `json:"avg"`
	Count      *OrderBy                 `json:"count"`
	Max        *TokensMaxOrderBy        `json:"max"`
	Min        *TokensMinOrderBy        `json:"min"`
	Stddev     *TokensStddevOrderBy     `json:"stddev"`
	StddevPop  *TokensStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TokensStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TokensSumOrderBy        `json:"sum"`
	VarPop     *TokensVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TokensVarSampOrderBy    `json:"var_samp"`
	Variance   *TokensVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "tokens"
type TokensArrRelInsertInput struct {
	Data []*TokensInsertInput `json:"data"`
	// on conflict condition
	OnConflict *TokensOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type TokensAvgFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by avg() on columns of table "tokens"
type TokensAvgOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'.
type TokensBoolExp struct {
	And        []*TokensBoolExp        `json:"_and"`
	Not        *TokensBoolExp          `json:"_not"`
	Or         []*TokensBoolExp        `json:"_or"`
	Created    *TimestampComparisonExp `json:"created"`
	Expiration *TimestampComparisonExp `json:"expiration"`
	ID         *IntComparisonExp       `json:"id"`
	Type       *StringComparisonExp    `json:"type"`
	User       *UsersBoolExp           `json:"user"`
	UserID     *IntComparisonExp       `json:"user_id"`
	Value      *StringComparisonExp    `json:"value"`
}

// input type for incrementing numeric columns in table "tokens"
type TokensIncInput struct {
	ID     *int64 `json:"id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "tokens"
type TokensInsertInput struct {
	Created    *time.Time              `json:"created"`
	Expiration *time.Time              `json:"expiration"`
	ID         *int64                  `json:"id"`
	Type       *string                 `json:"type"`
	User       *UsersObjRelInsertInput `json:"user"`
	UserID     *int64                  `json:"user_id"`
	Value      *string                 `json:"value"`
}

// aggregate max on columns
type TokensMaxFields struct {
	Created    *time.Time `json:"created"`
	Expiration *time.Time `json:"expiration"`
	ID         *int64     `json:"id"`
	Type       *string    `json:"type"`
	UserID     *int64     `json:"user_id"`
	Value      *string    `json:"value"`
}

// order by max() on columns of table "tokens"
type TokensMaxOrderBy struct {
	Created    *OrderBy `json:"created"`
	Expiration *OrderBy `json:"expiration"`
	ID         *OrderBy `json:"id"`
	Type       *OrderBy `json:"type"`
	UserID     *OrderBy `json:"user_id"`
	Value      *OrderBy `json:"value"`
}

// aggregate min on columns
type TokensMinFields struct {
	Created    *time.Time `json:"created"`
	Expiration *time.Time `json:"expiration"`
	ID         *int64     `json:"id"`
	Type       *string    `json:"type"`
	UserID     *int64     `json:"user_id"`
	Value      *string    `json:"value"`
}

// order by min() on columns of table "tokens"
type TokensMinOrderBy struct {
	Created    *OrderBy `json:"created"`
	Expiration *OrderBy `json:"expiration"`
	ID         *OrderBy `json:"id"`
	Type       *OrderBy `json:"type"`
	UserID     *OrderBy `json:"user_id"`
	Value      *OrderBy `json:"value"`
}

// response of any mutation on the table "tokens"
type TokensMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Tokens `json:"returning"`
}

// on conflict condition type for table "tokens"
type TokensOnConflict struct {
	Constraint    TokensConstraint     `json:"constraint"`
	UpdateColumns []TokensUpdateColumn `json:"update_columns"`
	Where         *TokensBoolExp       `json:"where"`
}

// Ordering options when selecting data from "tokens".
type TokensOrderBy struct {
	Created    *OrderBy      `json:"created"`
	Expiration *OrderBy      `json:"expiration"`
	ID         *OrderBy      `json:"id"`
	Type       *OrderBy      `json:"type"`
	User       *UsersOrderBy `json:"user"`
	UserID     *OrderBy      `json:"user_id"`
	Value      *OrderBy      `json:"value"`
}

// primary key columns input for table: tokens
type TokensPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "tokens"
type TokensSetInput struct {
	Created    *time.Time `json:"created"`
	Expiration *time.Time `json:"expiration"`
	ID         *int64     `json:"id"`
	Type       *string    `json:"type"`
	UserID     *int64     `json:"user_id"`
	Value      *string    `json:"value"`
}

// aggregate stddev on columns
type TokensStddevFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev() on columns of table "tokens"
type TokensStddevOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type TokensStddevPopFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "tokens"
type TokensStddevPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type TokensStddevSampFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "tokens"
type TokensStddevSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type TokensSumFields struct {
	ID     *int64 `json:"id"`
	UserID *int64 `json:"user_id"`
}

// order by sum() on columns of table "tokens"
type TokensSumOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type TokensVarPopFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "tokens"
type TokensVarPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type TokensVarSampFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "tokens"
type TokensVarSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type TokensVarianceFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by variance() on columns of table "tokens"
type TokensVarianceOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// columns and relationships of "tracking"
type Tracking struct {
	Date *time.Time `json:"date"`
	ID   int64      `json:"id"`
	IP   *string    `json:"ip"`
	Type *string    `json:"type"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "tracking"
type TrackingAggregate struct {
	Aggregate *TrackingAggregateFields `json:"aggregate"`
	Nodes     []*Tracking              `json:"nodes"`
}

// aggregate fields of "tracking"
type TrackingAggregateFields struct {
	Avg        *TrackingAvgFields        `json:"avg"`
	Count      int64                     `json:"count"`
	Max        *TrackingMaxFields        `json:"max"`
	Min        *TrackingMinFields        `json:"min"`
	Stddev     *TrackingStddevFields     `json:"stddev"`
	StddevPop  *TrackingStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TrackingStddevSampFields `json:"stddev_samp"`
	Sum        *TrackingSumFields        `json:"sum"`
	VarPop     *TrackingVarPopFields     `json:"var_pop"`
	VarSamp    *TrackingVarSampFields    `json:"var_samp"`
	Variance   *TrackingVarianceFields   `json:"variance"`
}

// order by aggregate values of table "tracking"
type TrackingAggregateOrderBy struct {
	Avg        *TrackingAvgOrderBy        `json:"avg"`
	Count      *OrderBy                   `json:"count"`
	Max        *TrackingMaxOrderBy        `json:"max"`
	Min        *TrackingMinOrderBy        `json:"min"`
	Stddev     *TrackingStddevOrderBy     `json:"stddev"`
	StddevPop  *TrackingStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TrackingStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TrackingSumOrderBy        `json:"sum"`
	VarPop     *TrackingVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TrackingVarSampOrderBy    `json:"var_samp"`
	Variance   *TrackingVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "tracking"
type TrackingArrRelInsertInput struct {
	Data []*TrackingInsertInput `json:"data"`
	// on conflict condition
	OnConflict *TrackingOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type TrackingAvgFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by avg() on columns of table "tracking"
type TrackingAvgOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "tracking". All fields are combined with a logical 'AND'.
type TrackingBoolExp struct {
	And    []*TrackingBoolExp      `json:"_and"`
	Not    *TrackingBoolExp        `json:"_not"`
	Or     []*TrackingBoolExp      `json:"_or"`
	Date   *TimestampComparisonExp `json:"date"`
	ID     *IntComparisonExp       `json:"id"`
	IP     *StringComparisonExp    `json:"ip"`
	Type   *StringComparisonExp    `json:"type"`
	User   *UsersBoolExp           `json:"user"`
	UserID *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "tracking"
type TrackingIncInput struct {
	ID     *int64 `json:"id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "tracking"
type TrackingInsertInput struct {
	Date   *time.Time              `json:"date"`
	ID     *int64                  `json:"id"`
	IP     *string                 `json:"ip"`
	Type   *string                 `json:"type"`
	User   *UsersObjRelInsertInput `json:"user"`
	UserID *int64                  `json:"user_id"`
}

// aggregate max on columns
type TrackingMaxFields struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	IP     *string    `json:"ip"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// order by max() on columns of table "tracking"
type TrackingMaxOrderBy struct {
	Date   *OrderBy `json:"date"`
	ID     *OrderBy `json:"id"`
	IP     *OrderBy `json:"ip"`
	Type   *OrderBy `json:"type"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate min on columns
type TrackingMinFields struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	IP     *string    `json:"ip"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// order by min() on columns of table "tracking"
type TrackingMinOrderBy struct {
	Date   *OrderBy `json:"date"`
	ID     *OrderBy `json:"id"`
	IP     *OrderBy `json:"ip"`
	Type   *OrderBy `json:"type"`
	UserID *OrderBy `json:"user_id"`
}

// response of any mutation on the table "tracking"
type TrackingMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Tracking `json:"returning"`
}

// on conflict condition type for table "tracking"
type TrackingOnConflict struct {
	Constraint    TrackingConstraint     `json:"constraint"`
	UpdateColumns []TrackingUpdateColumn `json:"update_columns"`
	Where         *TrackingBoolExp       `json:"where"`
}

// Ordering options when selecting data from "tracking".
type TrackingOrderBy struct {
	Date   *OrderBy      `json:"date"`
	ID     *OrderBy      `json:"id"`
	IP     *OrderBy      `json:"ip"`
	Type   *OrderBy      `json:"type"`
	User   *UsersOrderBy `json:"user"`
	UserID *OrderBy      `json:"user_id"`
}

// primary key columns input for table: tracking
type TrackingPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "tracking"
type TrackingSetInput struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	IP     *string    `json:"ip"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// aggregate stddev on columns
type TrackingStddevFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev() on columns of table "tracking"
type TrackingStddevOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type TrackingStddevPopFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "tracking"
type TrackingStddevPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type TrackingStddevSampFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "tracking"
type TrackingStddevSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type TrackingSumFields struct {
	ID     *int64 `json:"id"`
	UserID *int64 `json:"user_id"`
}

// order by sum() on columns of table "tracking"
type TrackingSumOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type TrackingVarPopFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "tracking"
type TrackingVarPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type TrackingVarSampFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "tracking"
type TrackingVarSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type TrackingVarianceFields struct {
	ID     *float64 `json:"id"`
	UserID *float64 `json:"user_id"`
}

// order by variance() on columns of table "tracking"
type TrackingVarianceOrderBy struct {
	ID     *OrderBy `json:"id"`
	UserID *OrderBy `json:"user_id"`
}

// columns and relationships of "unlocks"
type Unlocks struct {
	Date   *time.Time `json:"date"`
	ID     int64      `json:"id"`
	Target *int64     `json:"target"`
	// An object relationship
	TargetHint *Hints `json:"target_hint"`
	// An object relationship
	Team   *Teams  `json:"team"`
	TeamID *int64  `json:"team_id"`
	Type   *string `json:"type"`
	// An object relationship
	User   *Users `json:"user"`
	UserID *int64 `json:"user_id"`
}

// aggregated selection of "unlocks"
type UnlocksAggregate struct {
	Aggregate *UnlocksAggregateFields `json:"aggregate"`
	Nodes     []*Unlocks              `json:"nodes"`
}

// aggregate fields of "unlocks"
type UnlocksAggregateFields struct {
	Avg        *UnlocksAvgFields        `json:"avg"`
	Count      int64                    `json:"count"`
	Max        *UnlocksMaxFields        `json:"max"`
	Min        *UnlocksMinFields        `json:"min"`
	Stddev     *UnlocksStddevFields     `json:"stddev"`
	StddevPop  *UnlocksStddevPopFields  `json:"stddev_pop"`
	StddevSamp *UnlocksStddevSampFields `json:"stddev_samp"`
	Sum        *UnlocksSumFields        `json:"sum"`
	VarPop     *UnlocksVarPopFields     `json:"var_pop"`
	VarSamp    *UnlocksVarSampFields    `json:"var_samp"`
	Variance   *UnlocksVarianceFields   `json:"variance"`
}

// order by aggregate values of table "unlocks"
type UnlocksAggregateOrderBy struct {
	Avg        *UnlocksAvgOrderBy        `json:"avg"`
	Count      *OrderBy                  `json:"count"`
	Max        *UnlocksMaxOrderBy        `json:"max"`
	Min        *UnlocksMinOrderBy        `json:"min"`
	Stddev     *UnlocksStddevOrderBy     `json:"stddev"`
	StddevPop  *UnlocksStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *UnlocksStddevSampOrderBy `json:"stddev_samp"`
	Sum        *UnlocksSumOrderBy        `json:"sum"`
	VarPop     *UnlocksVarPopOrderBy     `json:"var_pop"`
	VarSamp    *UnlocksVarSampOrderBy    `json:"var_samp"`
	Variance   *UnlocksVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "unlocks"
type UnlocksArrRelInsertInput struct {
	Data []*UnlocksInsertInput `json:"data"`
	// on conflict condition
	OnConflict *UnlocksOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type UnlocksAvgFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by avg() on columns of table "unlocks"
type UnlocksAvgOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// Boolean expression to filter rows from the table "unlocks". All fields are combined with a logical 'AND'.
type UnlocksBoolExp struct {
	And        []*UnlocksBoolExp       `json:"_and"`
	Not        *UnlocksBoolExp         `json:"_not"`
	Or         []*UnlocksBoolExp       `json:"_or"`
	Date       *TimestampComparisonExp `json:"date"`
	ID         *IntComparisonExp       `json:"id"`
	Target     *IntComparisonExp       `json:"target"`
	TargetHint *HintsBoolExp           `json:"target_hint"`
	Team       *TeamsBoolExp           `json:"team"`
	TeamID     *IntComparisonExp       `json:"team_id"`
	Type       *StringComparisonExp    `json:"type"`
	User       *UsersBoolExp           `json:"user"`
	UserID     *IntComparisonExp       `json:"user_id"`
}

// input type for incrementing numeric columns in table "unlocks"
type UnlocksIncInput struct {
	ID     *int64 `json:"id"`
	Target *int64 `json:"target"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// input type for inserting data into table "unlocks"
type UnlocksInsertInput struct {
	Date       *time.Time              `json:"date"`
	ID         *int64                  `json:"id"`
	Target     *int64                  `json:"target"`
	TargetHint *HintsObjRelInsertInput `json:"target_hint"`
	Team       *TeamsObjRelInsertInput `json:"team"`
	TeamID     *int64                  `json:"team_id"`
	Type       *string                 `json:"type"`
	User       *UsersObjRelInsertInput `json:"user"`
	UserID     *int64                  `json:"user_id"`
}

// aggregate max on columns
type UnlocksMaxFields struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	Target *int64     `json:"target"`
	TeamID *int64     `json:"team_id"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// order by max() on columns of table "unlocks"
type UnlocksMaxOrderBy struct {
	Date   *OrderBy `json:"date"`
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	Type   *OrderBy `json:"type"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate min on columns
type UnlocksMinFields struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	Target *int64     `json:"target"`
	TeamID *int64     `json:"team_id"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// order by min() on columns of table "unlocks"
type UnlocksMinOrderBy struct {
	Date   *OrderBy `json:"date"`
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	Type   *OrderBy `json:"type"`
	UserID *OrderBy `json:"user_id"`
}

// response of any mutation on the table "unlocks"
type UnlocksMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Unlocks `json:"returning"`
}

// on conflict condition type for table "unlocks"
type UnlocksOnConflict struct {
	Constraint    UnlocksConstraint     `json:"constraint"`
	UpdateColumns []UnlocksUpdateColumn `json:"update_columns"`
	Where         *UnlocksBoolExp       `json:"where"`
}

// Ordering options when selecting data from "unlocks".
type UnlocksOrderBy struct {
	Date       *OrderBy      `json:"date"`
	ID         *OrderBy      `json:"id"`
	Target     *OrderBy      `json:"target"`
	TargetHint *HintsOrderBy `json:"target_hint"`
	Team       *TeamsOrderBy `json:"team"`
	TeamID     *OrderBy      `json:"team_id"`
	Type       *OrderBy      `json:"type"`
	User       *UsersOrderBy `json:"user"`
	UserID     *OrderBy      `json:"user_id"`
}

// primary key columns input for table: unlocks
type UnlocksPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "unlocks"
type UnlocksSetInput struct {
	Date   *time.Time `json:"date"`
	ID     *int64     `json:"id"`
	Target *int64     `json:"target"`
	TeamID *int64     `json:"team_id"`
	Type   *string    `json:"type"`
	UserID *int64     `json:"user_id"`
}

// aggregate stddev on columns
type UnlocksStddevFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev() on columns of table "unlocks"
type UnlocksStddevOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_pop on columns
type UnlocksStddevPopFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_pop() on columns of table "unlocks"
type UnlocksStddevPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate stddev_samp on columns
type UnlocksStddevSampFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by stddev_samp() on columns of table "unlocks"
type UnlocksStddevSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate sum on columns
type UnlocksSumFields struct {
	ID     *int64 `json:"id"`
	Target *int64 `json:"target"`
	TeamID *int64 `json:"team_id"`
	UserID *int64 `json:"user_id"`
}

// order by sum() on columns of table "unlocks"
type UnlocksSumOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_pop on columns
type UnlocksVarPopFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by var_pop() on columns of table "unlocks"
type UnlocksVarPopOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate var_samp on columns
type UnlocksVarSampFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by var_samp() on columns of table "unlocks"
type UnlocksVarSampOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// aggregate variance on columns
type UnlocksVarianceFields struct {
	ID     *float64 `json:"id"`
	Target *float64 `json:"target"`
	TeamID *float64 `json:"team_id"`
	UserID *float64 `json:"user_id"`
}

// order by variance() on columns of table "unlocks"
type UnlocksVarianceOrderBy struct {
	ID     *OrderBy `json:"id"`
	Target *OrderBy `json:"target"`
	TeamID *OrderBy `json:"team_id"`
	UserID *OrderBy `json:"user_id"`
}

// columns and relationships of "users"
type Users struct {
	Affiliation *string `json:"affiliation"`
	// A computed field, executes function "user_avatar"
	Avatar *string `json:"avatar"`
	// An array relationship
	Awards []*Awards `json:"awards"`
	// An aggregate relationship
	AwardsAggregate *AwardsAggregate `json:"awards_aggregate"`
	Banned          *bool            `json:"banned"`
	Bracket         *string          `json:"bracket"`
	// An object relationship
	CaptainOf *Teams `json:"captain_of"`
	// An array relationship
	Comments []*Comments `json:"comments"`
	// An array relationship
	CommentsByUserID []*Comments `json:"commentsByUserId"`
	// An aggregate relationship
	CommentsByUserIDAggregate *CommentsAggregate `json:"commentsByUserId_aggregate"`
	// An aggregate relationship
	CommentsAggregate *CommentsAggregate `json:"comments_aggregate"`
	Country           *string            `json:"country"`
	Created           *time.Time         `json:"created"`
	Email             *string            `json:"email"`
	// An array relationship
	FieldEntries []*FieldEntries `json:"field_entries"`
	// An aggregate relationship
	FieldEntriesAggregate *FieldEntriesAggregate `json:"field_entries_aggregate"`
	Hidden                *bool                  `json:"hidden"`
	ID                    int64                  `json:"id"`
	Name                  *string                `json:"name"`
	OauthID               *int64                 `json:"oauth_id"`
	Password              *string                `json:"password"`
	// A computed field, executes function "user_score"
	Score *int64 `json:"score"`
	// An array relationship
	ScoreTimeline []*ScoreTimelineUser `json:"score_timeline"`
	// An aggregate relationship
	ScoreTimelineAggregate *ScoreTimelineUserAggregate `json:"score_timeline_aggregate"`
	Secret                 *string                     `json:"secret"`
	// An array relationship
	Solves []*Solves `json:"solves"`
	// An aggregate relationship
	SolvesAggregate *SolvesAggregate `json:"solves_aggregate"`
	// An array relationship
	Submissions []*Submissions `json:"submissions"`
	// An aggregate relationship
	SubmissionsAggregate *SubmissionsAggregate `json:"submissions_aggregate"`
	// An object relationship
	Team   *Teams `json:"team"`
	TeamID *int64 `json:"team_id"`
	// An array relationship
	Tokens []*Tokens `json:"tokens"`
	// An aggregate relationship
	TokensAggregate *TokensAggregate `json:"tokens_aggregate"`
	// An array relationship
	Trackings []*Tracking `json:"trackings"`
	// An aggregate relationship
	TrackingsAggregate *TrackingAggregate `json:"trackings_aggregate"`
	Type               *string            `json:"type"`
	// An array relationship
	Unlocks []*Unlocks `json:"unlocks"`
	// An aggregate relationship
	UnlocksAggregate *UnlocksAggregate `json:"unlocks_aggregate"`
	Verified         *bool             `json:"verified"`
	Website          *string           `json:"website"`
}

// aggregated selection of "users"
type UsersAggregate struct {
	Aggregate *UsersAggregateFields `json:"aggregate"`
	Nodes     []*Users              `json:"nodes"`
}

// aggregate fields of "users"
type UsersAggregateFields struct {
	Avg        *UsersAvgFields        `json:"avg"`
	Count      int64                  `json:"count"`
	Max        *UsersMaxFields        `json:"max"`
	Min        *UsersMinFields        `json:"min"`
	Stddev     *UsersStddevFields     `json:"stddev"`
	StddevPop  *UsersStddevPopFields  `json:"stddev_pop"`
	StddevSamp *UsersStddevSampFields `json:"stddev_samp"`
	Sum        *UsersSumFields        `json:"sum"`
	VarPop     *UsersVarPopFields     `json:"var_pop"`
	VarSamp    *UsersVarSampFields    `json:"var_samp"`
	Variance   *UsersVarianceFields   `json:"variance"`
}

// order by aggregate values of table "users"
type UsersAggregateOrderBy struct {
	Avg        *UsersAvgOrderBy        `json:"avg"`
	Count      *OrderBy                `json:"count"`
	Max        *UsersMaxOrderBy        `json:"max"`
	Min        *UsersMinOrderBy        `json:"min"`
	Stddev     *UsersStddevOrderBy     `json:"stddev"`
	StddevPop  *UsersStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *UsersStddevSampOrderBy `json:"stddev_samp"`
	Sum        *UsersSumOrderBy        `json:"sum"`
	VarPop     *UsersVarPopOrderBy     `json:"var_pop"`
	VarSamp    *UsersVarSampOrderBy    `json:"var_samp"`
	Variance   *UsersVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "users"
type UsersArrRelInsertInput struct {
	Data []*UsersInsertInput `json:"data"`
	// on conflict condition
	OnConflict *UsersOnConflict `json:"on_conflict"`
}

// aggregate avg on columns
type UsersAvgFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by avg() on columns of table "users"
type UsersAvgOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
type UsersBoolExp struct {
	And              []*UsersBoolExp           `json:"_and"`
	Not              *UsersBoolExp             `json:"_not"`
	Or               []*UsersBoolExp           `json:"_or"`
	Affiliation      *StringComparisonExp      `json:"affiliation"`
	Awards           *AwardsBoolExp            `json:"awards"`
	Banned           *BooleanComparisonExp     `json:"banned"`
	Bracket          *StringComparisonExp      `json:"bracket"`
	CaptainOf        *TeamsBoolExp             `json:"captain_of"`
	Comments         *CommentsBoolExp          `json:"comments"`
	CommentsByUserID *CommentsBoolExp          `json:"commentsByUserId"`
	Country          *StringComparisonExp      `json:"country"`
	Created          *TimestampComparisonExp   `json:"created"`
	Email            *StringComparisonExp      `json:"email"`
	FieldEntries     *FieldEntriesBoolExp      `json:"field_entries"`
	Hidden           *BooleanComparisonExp     `json:"hidden"`
	ID               *IntComparisonExp         `json:"id"`
	Name             *StringComparisonExp      `json:"name"`
	OauthID          *IntComparisonExp         `json:"oauth_id"`
	Password         *StringComparisonExp      `json:"password"`
	ScoreTimeline    *ScoreTimelineUserBoolExp `json:"score_timeline"`
	Secret           *StringComparisonExp      `json:"secret"`
	Solves           *SolvesBoolExp            `json:"solves"`
	Submissions      *SubmissionsBoolExp       `json:"submissions"`
	Team             *TeamsBoolExp             `json:"team"`
	TeamID           *IntComparisonExp         `json:"team_id"`
	Tokens           *TokensBoolExp            `json:"tokens"`
	Trackings        *TrackingBoolExp          `json:"trackings"`
	Type             *StringComparisonExp      `json:"type"`
	Unlocks          *UnlocksBoolExp           `json:"unlocks"`
	Verified         *BooleanComparisonExp     `json:"verified"`
	Website          *StringComparisonExp      `json:"website"`
}

// input type for incrementing numeric columns in table "users"
type UsersIncInput struct {
	ID      *int64 `json:"id"`
	OauthID *int64 `json:"oauth_id"`
	TeamID  *int64 `json:"team_id"`
}

// input type for inserting data into table "users"
type UsersInsertInput struct {
	Affiliation      *string                             `json:"affiliation"`
	Awards           *AwardsArrRelInsertInput            `json:"awards"`
	Banned           *bool                               `json:"banned"`
	Bracket          *string                             `json:"bracket"`
	CaptainOf        *TeamsObjRelInsertInput             `json:"captain_of"`
	Comments         *CommentsArrRelInsertInput          `json:"comments"`
	CommentsByUserID *CommentsArrRelInsertInput          `json:"commentsByUserId"`
	Country          *string                             `json:"country"`
	Created          *time.Time                          `json:"created"`
	Email            *string                             `json:"email"`
	FieldEntries     *FieldEntriesArrRelInsertInput      `json:"field_entries"`
	Hidden           *bool                               `json:"hidden"`
	ID               *int64                              `json:"id"`
	Name             *string                             `json:"name"`
	OauthID          *int64                              `json:"oauth_id"`
	Password         *string                             `json:"password"`
	ScoreTimeline    *ScoreTimelineUserArrRelInsertInput `json:"score_timeline"`
	Secret           *string                             `json:"secret"`
	Solves           *SolvesArrRelInsertInput            `json:"solves"`
	Submissions      *SubmissionsArrRelInsertInput       `json:"submissions"`
	Team             *TeamsObjRelInsertInput             `json:"team"`
	TeamID           *int64                              `json:"team_id"`
	Tokens           *TokensArrRelInsertInput            `json:"tokens"`
	Trackings        *TrackingArrRelInsertInput          `json:"trackings"`
	Type             *string                             `json:"type"`
	Unlocks          *UnlocksArrRelInsertInput           `json:"unlocks"`
	Verified         *bool                               `json:"verified"`
	Website          *string                             `json:"website"`
}

// aggregate max on columns
type UsersMaxFields struct {
	Affiliation *string    `json:"affiliation"`
	Bracket     *string    `json:"bracket"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	Website     *string    `json:"website"`
}

// order by max() on columns of table "users"
type UsersMaxOrderBy struct {
	Affiliation *OrderBy `json:"affiliation"`
	Bracket     *OrderBy `json:"bracket"`
	Country     *OrderBy `json:"country"`
	Created     *OrderBy `json:"created"`
	Email       *OrderBy `json:"email"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	OauthID     *OrderBy `json:"oauth_id"`
	Password    *OrderBy `json:"password"`
	Secret      *OrderBy `json:"secret"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	Website     *OrderBy `json:"website"`
}

// aggregate min on columns
type UsersMinFields struct {
	Affiliation *string    `json:"affiliation"`
	Bracket     *string    `json:"bracket"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	Website     *string    `json:"website"`
}

// order by min() on columns of table "users"
type UsersMinOrderBy struct {
	Affiliation *OrderBy `json:"affiliation"`
	Bracket     *OrderBy `json:"bracket"`
	Country     *OrderBy `json:"country"`
	Created     *OrderBy `json:"created"`
	Email       *OrderBy `json:"email"`
	ID          *OrderBy `json:"id"`
	Name        *OrderBy `json:"name"`
	OauthID     *OrderBy `json:"oauth_id"`
	Password    *OrderBy `json:"password"`
	Secret      *OrderBy `json:"secret"`
	TeamID      *OrderBy `json:"team_id"`
	Type        *OrderBy `json:"type"`
	Website     *OrderBy `json:"website"`
}

// response of any mutation on the table "users"
type UsersMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Users `json:"returning"`
}

// input type for inserting object relation for remote table "users"
type UsersObjRelInsertInput struct {
	Data *UsersInsertInput `json:"data"`
	// on conflict condition
	OnConflict *UsersOnConflict `json:"on_conflict"`
}

// on conflict condition type for table "users"
type UsersOnConflict struct {
	Constraint    UsersConstraint     `json:"constraint"`
	UpdateColumns []UsersUpdateColumn `json:"update_columns"`
	Where         *UsersBoolExp       `json:"where"`
}

// Ordering options when selecting data from "users".
type UsersOrderBy struct {
	Affiliation               *OrderBy                           `json:"affiliation"`
	AwardsAggregate           *AwardsAggregateOrderBy            `json:"awards_aggregate"`
	Banned                    *OrderBy                           `json:"banned"`
	Bracket                   *OrderBy                           `json:"bracket"`
	CaptainOf                 *TeamsOrderBy                      `json:"captain_of"`
	CommentsByUserIDAggregate *CommentsAggregateOrderBy          `json:"commentsByUserId_aggregate"`
	CommentsAggregate         *CommentsAggregateOrderBy          `json:"comments_aggregate"`
	Country                   *OrderBy                           `json:"country"`
	Created                   *OrderBy                           `json:"created"`
	Email                     *OrderBy                           `json:"email"`
	FieldEntriesAggregate     *FieldEntriesAggregateOrderBy      `json:"field_entries_aggregate"`
	Hidden                    *OrderBy                           `json:"hidden"`
	ID                        *OrderBy                           `json:"id"`
	Name                      *OrderBy                           `json:"name"`
	OauthID                   *OrderBy                           `json:"oauth_id"`
	Password                  *OrderBy                           `json:"password"`
	ScoreTimelineAggregate    *ScoreTimelineUserAggregateOrderBy `json:"score_timeline_aggregate"`
	Secret                    *OrderBy                           `json:"secret"`
	SolvesAggregate           *SolvesAggregateOrderBy            `json:"solves_aggregate"`
	SubmissionsAggregate      *SubmissionsAggregateOrderBy       `json:"submissions_aggregate"`
	Team                      *TeamsOrderBy                      `json:"team"`
	TeamID                    *OrderBy                           `json:"team_id"`
	TokensAggregate           *TokensAggregateOrderBy            `json:"tokens_aggregate"`
	TrackingsAggregate        *TrackingAggregateOrderBy          `json:"trackings_aggregate"`
	Type                      *OrderBy                           `json:"type"`
	UnlocksAggregate          *UnlocksAggregateOrderBy           `json:"unlocks_aggregate"`
	Verified                  *OrderBy                           `json:"verified"`
	Website                   *OrderBy                           `json:"website"`
}

// primary key columns input for table: users
type UsersPkColumnsInput struct {
	ID int64 `json:"id"`
}

// input type for updating data in table "users"
type UsersSetInput struct {
	Affiliation *string    `json:"affiliation"`
	Banned      *bool      `json:"banned"`
	Bracket     *string    `json:"bracket"`
	Country     *string    `json:"country"`
	Created     *time.Time `json:"created"`
	Email       *string    `json:"email"`
	Hidden      *bool      `json:"hidden"`
	ID          *int64     `json:"id"`
	Name        *string    `json:"name"`
	OauthID     *int64     `json:"oauth_id"`
	Password    *string    `json:"password"`
	Secret      *string    `json:"secret"`
	TeamID      *int64     `json:"team_id"`
	Type        *string    `json:"type"`
	Verified    *bool      `json:"verified"`
	Website     *string    `json:"website"`
}

// aggregate stddev on columns
type UsersStddevFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by stddev() on columns of table "users"
type UsersStddevOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate stddev_pop on columns
type UsersStddevPopFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by stddev_pop() on columns of table "users"
type UsersStddevPopOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate stddev_samp on columns
type UsersStddevSampFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by stddev_samp() on columns of table "users"
type UsersStddevSampOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate sum on columns
type UsersSumFields struct {
	ID      *int64 `json:"id"`
	OauthID *int64 `json:"oauth_id"`
	TeamID  *int64 `json:"team_id"`
}

// order by sum() on columns of table "users"
type UsersSumOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate var_pop on columns
type UsersVarPopFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by var_pop() on columns of table "users"
type UsersVarPopOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate var_samp on columns
type UsersVarSampFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by var_samp() on columns of table "users"
type UsersVarSampOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// aggregate variance on columns
type UsersVarianceFields struct {
	ID      *float64 `json:"id"`
	OauthID *float64 `json:"oauth_id"`
	TeamID  *float64 `json:"team_id"`
}

// order by variance() on columns of table "users"
type UsersVarianceOrderBy struct {
	ID      *OrderBy `json:"id"`
	OauthID *OrderBy `json:"oauth_id"`
	TeamID  *OrderBy `json:"team_id"`
}

// unique or primary key constraints on table "awards"
type AwardsConstraint string

const (
	// unique or primary key constraint
	AwardsConstraintAwardsPkey AwardsConstraint = "awards_pkey"
)

var AllAwardsConstraint = []AwardsConstraint{
	AwardsConstraintAwardsPkey,
}

func (e AwardsConstraint) IsValid() bool {
	switch e {
	case AwardsConstraintAwardsPkey:
		return true
	}
	return false
}

func (e AwardsConstraint) String() string {
	return string(e)
}

func (e *AwardsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AwardsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid awards_constraint", str)
	}
	return nil
}

func (e AwardsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "awards"
type AwardsSelectColumn string

const (
	// column name
	AwardsSelectColumnCategory AwardsSelectColumn = "category"
	// column name
	AwardsSelectColumnDate AwardsSelectColumn = "date"
	// column name
	AwardsSelectColumnDescription AwardsSelectColumn = "description"
	// column name
	AwardsSelectColumnIcon AwardsSelectColumn = "icon"
	// column name
	AwardsSelectColumnID AwardsSelectColumn = "id"
	// column name
	AwardsSelectColumnName AwardsSelectColumn = "name"
	// column name
	AwardsSelectColumnRequirements AwardsSelectColumn = "requirements"
	// column name
	AwardsSelectColumnTeamID AwardsSelectColumn = "team_id"
	// column name
	AwardsSelectColumnType AwardsSelectColumn = "type"
	// column name
	AwardsSelectColumnUserID AwardsSelectColumn = "user_id"
	// column name
	AwardsSelectColumnValue AwardsSelectColumn = "value"
)

var AllAwardsSelectColumn = []AwardsSelectColumn{
	AwardsSelectColumnCategory,
	AwardsSelectColumnDate,
	AwardsSelectColumnDescription,
	AwardsSelectColumnIcon,
	AwardsSelectColumnID,
	AwardsSelectColumnName,
	AwardsSelectColumnRequirements,
	AwardsSelectColumnTeamID,
	AwardsSelectColumnType,
	AwardsSelectColumnUserID,
	AwardsSelectColumnValue,
}

func (e AwardsSelectColumn) IsValid() bool {
	switch e {
	case AwardsSelectColumnCategory, AwardsSelectColumnDate, AwardsSelectColumnDescription, AwardsSelectColumnIcon, AwardsSelectColumnID, AwardsSelectColumnName, AwardsSelectColumnRequirements, AwardsSelectColumnTeamID, AwardsSelectColumnType, AwardsSelectColumnUserID, AwardsSelectColumnValue:
		return true
	}
	return false
}

func (e AwardsSelectColumn) String() string {
	return string(e)
}

func (e *AwardsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AwardsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid awards_select_column", str)
	}
	return nil
}

func (e AwardsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "awards"
type AwardsUpdateColumn string

const (
	// column name
	AwardsUpdateColumnCategory AwardsUpdateColumn = "category"
	// column name
	AwardsUpdateColumnDate AwardsUpdateColumn = "date"
	// column name
	AwardsUpdateColumnDescription AwardsUpdateColumn = "description"
	// column name
	AwardsUpdateColumnIcon AwardsUpdateColumn = "icon"
	// column name
	AwardsUpdateColumnID AwardsUpdateColumn = "id"
	// column name
	AwardsUpdateColumnName AwardsUpdateColumn = "name"
	// column name
	AwardsUpdateColumnRequirements AwardsUpdateColumn = "requirements"
	// column name
	AwardsUpdateColumnTeamID AwardsUpdateColumn = "team_id"
	// column name
	AwardsUpdateColumnType AwardsUpdateColumn = "type"
	// column name
	AwardsUpdateColumnUserID AwardsUpdateColumn = "user_id"
	// column name
	AwardsUpdateColumnValue AwardsUpdateColumn = "value"
)

var AllAwardsUpdateColumn = []AwardsUpdateColumn{
	AwardsUpdateColumnCategory,
	AwardsUpdateColumnDate,
	AwardsUpdateColumnDescription,
	AwardsUpdateColumnIcon,
	AwardsUpdateColumnID,
	AwardsUpdateColumnName,
	AwardsUpdateColumnRequirements,
	AwardsUpdateColumnTeamID,
	AwardsUpdateColumnType,
	AwardsUpdateColumnUserID,
	AwardsUpdateColumnValue,
}

func (e AwardsUpdateColumn) IsValid() bool {
	switch e {
	case AwardsUpdateColumnCategory, AwardsUpdateColumnDate, AwardsUpdateColumnDescription, AwardsUpdateColumnIcon, AwardsUpdateColumnID, AwardsUpdateColumnName, AwardsUpdateColumnRequirements, AwardsUpdateColumnTeamID, AwardsUpdateColumnType, AwardsUpdateColumnUserID, AwardsUpdateColumnValue:
		return true
	}
	return false
}

func (e AwardsUpdateColumn) String() string {
	return string(e)
}

func (e *AwardsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AwardsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid awards_update_column", str)
	}
	return nil
}

func (e AwardsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "challenges"
type ChallengesConstraint string

const (
	// unique or primary key constraint
	ChallengesConstraintChallengesPkey ChallengesConstraint = "challenges_pkey"
)

var AllChallengesConstraint = []ChallengesConstraint{
	ChallengesConstraintChallengesPkey,
}

func (e ChallengesConstraint) IsValid() bool {
	switch e {
	case ChallengesConstraintChallengesPkey:
		return true
	}
	return false
}

func (e ChallengesConstraint) String() string {
	return string(e)
}

func (e *ChallengesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid challenges_constraint", str)
	}
	return nil
}

func (e ChallengesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "challenges"
type ChallengesSelectColumn string

const (
	// column name
	ChallengesSelectColumnCategory ChallengesSelectColumn = "category"
	// column name
	ChallengesSelectColumnDescription ChallengesSelectColumn = "description"
	// column name
	ChallengesSelectColumnID ChallengesSelectColumn = "id"
	// column name
	ChallengesSelectColumnMaxAttempts ChallengesSelectColumn = "max_attempts"
	// column name
	ChallengesSelectColumnName ChallengesSelectColumn = "name"
	// column name
	ChallengesSelectColumnRequirements ChallengesSelectColumn = "requirements"
	// column name
	ChallengesSelectColumnState ChallengesSelectColumn = "state"
	// column name
	ChallengesSelectColumnType ChallengesSelectColumn = "type"
	// column name
	ChallengesSelectColumnValue ChallengesSelectColumn = "value"
)

var AllChallengesSelectColumn = []ChallengesSelectColumn{
	ChallengesSelectColumnCategory,
	ChallengesSelectColumnDescription,
	ChallengesSelectColumnID,
	ChallengesSelectColumnMaxAttempts,
	ChallengesSelectColumnName,
	ChallengesSelectColumnRequirements,
	ChallengesSelectColumnState,
	ChallengesSelectColumnType,
	ChallengesSelectColumnValue,
}

func (e ChallengesSelectColumn) IsValid() bool {
	switch e {
	case ChallengesSelectColumnCategory, ChallengesSelectColumnDescription, ChallengesSelectColumnID, ChallengesSelectColumnMaxAttempts, ChallengesSelectColumnName, ChallengesSelectColumnRequirements, ChallengesSelectColumnState, ChallengesSelectColumnType, ChallengesSelectColumnValue:
		return true
	}
	return false
}

func (e ChallengesSelectColumn) String() string {
	return string(e)
}

func (e *ChallengesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid challenges_select_column", str)
	}
	return nil
}

func (e ChallengesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "challenges"
type ChallengesUpdateColumn string

const (
	// column name
	ChallengesUpdateColumnCategory ChallengesUpdateColumn = "category"
	// column name
	ChallengesUpdateColumnDescription ChallengesUpdateColumn = "description"
	// column name
	ChallengesUpdateColumnID ChallengesUpdateColumn = "id"
	// column name
	ChallengesUpdateColumnMaxAttempts ChallengesUpdateColumn = "max_attempts"
	// column name
	ChallengesUpdateColumnName ChallengesUpdateColumn = "name"
	// column name
	ChallengesUpdateColumnRequirements ChallengesUpdateColumn = "requirements"
	// column name
	ChallengesUpdateColumnState ChallengesUpdateColumn = "state"
	// column name
	ChallengesUpdateColumnType ChallengesUpdateColumn = "type"
	// column name
	ChallengesUpdateColumnValue ChallengesUpdateColumn = "value"
)

var AllChallengesUpdateColumn = []ChallengesUpdateColumn{
	ChallengesUpdateColumnCategory,
	ChallengesUpdateColumnDescription,
	ChallengesUpdateColumnID,
	ChallengesUpdateColumnMaxAttempts,
	ChallengesUpdateColumnName,
	ChallengesUpdateColumnRequirements,
	ChallengesUpdateColumnState,
	ChallengesUpdateColumnType,
	ChallengesUpdateColumnValue,
}

func (e ChallengesUpdateColumn) IsValid() bool {
	switch e {
	case ChallengesUpdateColumnCategory, ChallengesUpdateColumnDescription, ChallengesUpdateColumnID, ChallengesUpdateColumnMaxAttempts, ChallengesUpdateColumnName, ChallengesUpdateColumnRequirements, ChallengesUpdateColumnState, ChallengesUpdateColumnType, ChallengesUpdateColumnValue:
		return true
	}
	return false
}

func (e ChallengesUpdateColumn) String() string {
	return string(e)
}

func (e *ChallengesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid challenges_update_column", str)
	}
	return nil
}

func (e ChallengesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "comments"
type CommentsConstraint string

const (
	// unique or primary key constraint
	CommentsConstraintCommentsPkey CommentsConstraint = "comments_pkey"
)

var AllCommentsConstraint = []CommentsConstraint{
	CommentsConstraintCommentsPkey,
}

func (e CommentsConstraint) IsValid() bool {
	switch e {
	case CommentsConstraintCommentsPkey:
		return true
	}
	return false
}

func (e CommentsConstraint) String() string {
	return string(e)
}

func (e *CommentsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid comments_constraint", str)
	}
	return nil
}

func (e CommentsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "comments"
type CommentsSelectColumn string

const (
	// column name
	CommentsSelectColumnAuthorID CommentsSelectColumn = "author_id"
	// column name
	CommentsSelectColumnChallengeID CommentsSelectColumn = "challenge_id"
	// column name
	CommentsSelectColumnContent CommentsSelectColumn = "content"
	// column name
	CommentsSelectColumnDate CommentsSelectColumn = "date"
	// column name
	CommentsSelectColumnID CommentsSelectColumn = "id"
	// column name
	CommentsSelectColumnPageID CommentsSelectColumn = "page_id"
	// column name
	CommentsSelectColumnTeamID CommentsSelectColumn = "team_id"
	// column name
	CommentsSelectColumnType CommentsSelectColumn = "type"
	// column name
	CommentsSelectColumnUserID CommentsSelectColumn = "user_id"
)

var AllCommentsSelectColumn = []CommentsSelectColumn{
	CommentsSelectColumnAuthorID,
	CommentsSelectColumnChallengeID,
	CommentsSelectColumnContent,
	CommentsSelectColumnDate,
	CommentsSelectColumnID,
	CommentsSelectColumnPageID,
	CommentsSelectColumnTeamID,
	CommentsSelectColumnType,
	CommentsSelectColumnUserID,
}

func (e CommentsSelectColumn) IsValid() bool {
	switch e {
	case CommentsSelectColumnAuthorID, CommentsSelectColumnChallengeID, CommentsSelectColumnContent, CommentsSelectColumnDate, CommentsSelectColumnID, CommentsSelectColumnPageID, CommentsSelectColumnTeamID, CommentsSelectColumnType, CommentsSelectColumnUserID:
		return true
	}
	return false
}

func (e CommentsSelectColumn) String() string {
	return string(e)
}

func (e *CommentsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid comments_select_column", str)
	}
	return nil
}

func (e CommentsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "comments"
type CommentsUpdateColumn string

const (
	// column name
	CommentsUpdateColumnAuthorID CommentsUpdateColumn = "author_id"
	// column name
	CommentsUpdateColumnChallengeID CommentsUpdateColumn = "challenge_id"
	// column name
	CommentsUpdateColumnContent CommentsUpdateColumn = "content"
	// column name
	CommentsUpdateColumnDate CommentsUpdateColumn = "date"
	// column name
	CommentsUpdateColumnID CommentsUpdateColumn = "id"
	// column name
	CommentsUpdateColumnPageID CommentsUpdateColumn = "page_id"
	// column name
	CommentsUpdateColumnTeamID CommentsUpdateColumn = "team_id"
	// column name
	CommentsUpdateColumnType CommentsUpdateColumn = "type"
	// column name
	CommentsUpdateColumnUserID CommentsUpdateColumn = "user_id"
)

var AllCommentsUpdateColumn = []CommentsUpdateColumn{
	CommentsUpdateColumnAuthorID,
	CommentsUpdateColumnChallengeID,
	CommentsUpdateColumnContent,
	CommentsUpdateColumnDate,
	CommentsUpdateColumnID,
	CommentsUpdateColumnPageID,
	CommentsUpdateColumnTeamID,
	CommentsUpdateColumnType,
	CommentsUpdateColumnUserID,
}

func (e CommentsUpdateColumn) IsValid() bool {
	switch e {
	case CommentsUpdateColumnAuthorID, CommentsUpdateColumnChallengeID, CommentsUpdateColumnContent, CommentsUpdateColumnDate, CommentsUpdateColumnID, CommentsUpdateColumnPageID, CommentsUpdateColumnTeamID, CommentsUpdateColumnType, CommentsUpdateColumnUserID:
		return true
	}
	return false
}

func (e CommentsUpdateColumn) String() string {
	return string(e)
}

func (e *CommentsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid comments_update_column", str)
	}
	return nil
}

func (e CommentsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "config"
type ConfigConstraint string

const (
	// unique or primary key constraint
	ConfigConstraintConfigPkey ConfigConstraint = "config_pkey"
)

var AllConfigConstraint = []ConfigConstraint{
	ConfigConstraintConfigPkey,
}

func (e ConfigConstraint) IsValid() bool {
	switch e {
	case ConfigConstraintConfigPkey:
		return true
	}
	return false
}

func (e ConfigConstraint) String() string {
	return string(e)
}

func (e *ConfigConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid config_constraint", str)
	}
	return nil
}

func (e ConfigConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "config"
type ConfigSelectColumn string

const (
	// column name
	ConfigSelectColumnID ConfigSelectColumn = "id"
	// column name
	ConfigSelectColumnKey ConfigSelectColumn = "key"
	// column name
	ConfigSelectColumnValue ConfigSelectColumn = "value"
)

var AllConfigSelectColumn = []ConfigSelectColumn{
	ConfigSelectColumnID,
	ConfigSelectColumnKey,
	ConfigSelectColumnValue,
}

func (e ConfigSelectColumn) IsValid() bool {
	switch e {
	case ConfigSelectColumnID, ConfigSelectColumnKey, ConfigSelectColumnValue:
		return true
	}
	return false
}

func (e ConfigSelectColumn) String() string {
	return string(e)
}

func (e *ConfigSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid config_select_column", str)
	}
	return nil
}

func (e ConfigSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "config"
type ConfigUpdateColumn string

const (
	// column name
	ConfigUpdateColumnID ConfigUpdateColumn = "id"
	// column name
	ConfigUpdateColumnKey ConfigUpdateColumn = "key"
	// column name
	ConfigUpdateColumnValue ConfigUpdateColumn = "value"
)

var AllConfigUpdateColumn = []ConfigUpdateColumn{
	ConfigUpdateColumnID,
	ConfigUpdateColumnKey,
	ConfigUpdateColumnValue,
}

func (e ConfigUpdateColumn) IsValid() bool {
	switch e {
	case ConfigUpdateColumnID, ConfigUpdateColumnKey, ConfigUpdateColumnValue:
		return true
	}
	return false
}

func (e ConfigUpdateColumn) String() string {
	return string(e)
}

func (e *ConfigUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid config_update_column", str)
	}
	return nil
}

func (e ConfigUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "dynamic_challenge"
type DynamicChallengeConstraint string

const (
	// unique or primary key constraint
	DynamicChallengeConstraintDynamicChallengePkey DynamicChallengeConstraint = "dynamic_challenge_pkey"
)

var AllDynamicChallengeConstraint = []DynamicChallengeConstraint{
	DynamicChallengeConstraintDynamicChallengePkey,
}

func (e DynamicChallengeConstraint) IsValid() bool {
	switch e {
	case DynamicChallengeConstraintDynamicChallengePkey:
		return true
	}
	return false
}

func (e DynamicChallengeConstraint) String() string {
	return string(e)
}

func (e *DynamicChallengeConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DynamicChallengeConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid dynamic_challenge_constraint", str)
	}
	return nil
}

func (e DynamicChallengeConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "dynamic_challenge"
type DynamicChallengeSelectColumn string

const (
	// column name
	DynamicChallengeSelectColumnDecay DynamicChallengeSelectColumn = "decay"
	// column name
	DynamicChallengeSelectColumnID DynamicChallengeSelectColumn = "id"
	// column name
	DynamicChallengeSelectColumnInitial DynamicChallengeSelectColumn = "initial"
	// column name
	DynamicChallengeSelectColumnMinimum DynamicChallengeSelectColumn = "minimum"
)

var AllDynamicChallengeSelectColumn = []DynamicChallengeSelectColumn{
	DynamicChallengeSelectColumnDecay,
	DynamicChallengeSelectColumnID,
	DynamicChallengeSelectColumnInitial,
	DynamicChallengeSelectColumnMinimum,
}

func (e DynamicChallengeSelectColumn) IsValid() bool {
	switch e {
	case DynamicChallengeSelectColumnDecay, DynamicChallengeSelectColumnID, DynamicChallengeSelectColumnInitial, DynamicChallengeSelectColumnMinimum:
		return true
	}
	return false
}

func (e DynamicChallengeSelectColumn) String() string {
	return string(e)
}

func (e *DynamicChallengeSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DynamicChallengeSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid dynamic_challenge_select_column", str)
	}
	return nil
}

func (e DynamicChallengeSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "dynamic_challenge"
type DynamicChallengeUpdateColumn string

const (
	// column name
	DynamicChallengeUpdateColumnDecay DynamicChallengeUpdateColumn = "decay"
	// column name
	DynamicChallengeUpdateColumnID DynamicChallengeUpdateColumn = "id"
	// column name
	DynamicChallengeUpdateColumnInitial DynamicChallengeUpdateColumn = "initial"
	// column name
	DynamicChallengeUpdateColumnMinimum DynamicChallengeUpdateColumn = "minimum"
)

var AllDynamicChallengeUpdateColumn = []DynamicChallengeUpdateColumn{
	DynamicChallengeUpdateColumnDecay,
	DynamicChallengeUpdateColumnID,
	DynamicChallengeUpdateColumnInitial,
	DynamicChallengeUpdateColumnMinimum,
}

func (e DynamicChallengeUpdateColumn) IsValid() bool {
	switch e {
	case DynamicChallengeUpdateColumnDecay, DynamicChallengeUpdateColumnID, DynamicChallengeUpdateColumnInitial, DynamicChallengeUpdateColumnMinimum:
		return true
	}
	return false
}

func (e DynamicChallengeUpdateColumn) String() string {
	return string(e)
}

func (e *DynamicChallengeUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DynamicChallengeUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid dynamic_challenge_update_column", str)
	}
	return nil
}

func (e DynamicChallengeUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "field_entries"
type FieldEntriesConstraint string

const (
	// unique or primary key constraint
	FieldEntriesConstraintFieldEntriesPkey FieldEntriesConstraint = "field_entries_pkey"
)

var AllFieldEntriesConstraint = []FieldEntriesConstraint{
	FieldEntriesConstraintFieldEntriesPkey,
}

func (e FieldEntriesConstraint) IsValid() bool {
	switch e {
	case FieldEntriesConstraintFieldEntriesPkey:
		return true
	}
	return false
}

func (e FieldEntriesConstraint) String() string {
	return string(e)
}

func (e *FieldEntriesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldEntriesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid field_entries_constraint", str)
	}
	return nil
}

func (e FieldEntriesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "field_entries"
type FieldEntriesSelectColumn string

const (
	// column name
	FieldEntriesSelectColumnFieldID FieldEntriesSelectColumn = "field_id"
	// column name
	FieldEntriesSelectColumnID FieldEntriesSelectColumn = "id"
	// column name
	FieldEntriesSelectColumnTeamID FieldEntriesSelectColumn = "team_id"
	// column name
	FieldEntriesSelectColumnType FieldEntriesSelectColumn = "type"
	// column name
	FieldEntriesSelectColumnUserID FieldEntriesSelectColumn = "user_id"
	// column name
	FieldEntriesSelectColumnValue FieldEntriesSelectColumn = "value"
)

var AllFieldEntriesSelectColumn = []FieldEntriesSelectColumn{
	FieldEntriesSelectColumnFieldID,
	FieldEntriesSelectColumnID,
	FieldEntriesSelectColumnTeamID,
	FieldEntriesSelectColumnType,
	FieldEntriesSelectColumnUserID,
	FieldEntriesSelectColumnValue,
}

func (e FieldEntriesSelectColumn) IsValid() bool {
	switch e {
	case FieldEntriesSelectColumnFieldID, FieldEntriesSelectColumnID, FieldEntriesSelectColumnTeamID, FieldEntriesSelectColumnType, FieldEntriesSelectColumnUserID, FieldEntriesSelectColumnValue:
		return true
	}
	return false
}

func (e FieldEntriesSelectColumn) String() string {
	return string(e)
}

func (e *FieldEntriesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldEntriesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid field_entries_select_column", str)
	}
	return nil
}

func (e FieldEntriesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "field_entries"
type FieldEntriesUpdateColumn string

const (
	// column name
	FieldEntriesUpdateColumnFieldID FieldEntriesUpdateColumn = "field_id"
	// column name
	FieldEntriesUpdateColumnID FieldEntriesUpdateColumn = "id"
	// column name
	FieldEntriesUpdateColumnTeamID FieldEntriesUpdateColumn = "team_id"
	// column name
	FieldEntriesUpdateColumnType FieldEntriesUpdateColumn = "type"
	// column name
	FieldEntriesUpdateColumnUserID FieldEntriesUpdateColumn = "user_id"
	// column name
	FieldEntriesUpdateColumnValue FieldEntriesUpdateColumn = "value"
)

var AllFieldEntriesUpdateColumn = []FieldEntriesUpdateColumn{
	FieldEntriesUpdateColumnFieldID,
	FieldEntriesUpdateColumnID,
	FieldEntriesUpdateColumnTeamID,
	FieldEntriesUpdateColumnType,
	FieldEntriesUpdateColumnUserID,
	FieldEntriesUpdateColumnValue,
}

func (e FieldEntriesUpdateColumn) IsValid() bool {
	switch e {
	case FieldEntriesUpdateColumnFieldID, FieldEntriesUpdateColumnID, FieldEntriesUpdateColumnTeamID, FieldEntriesUpdateColumnType, FieldEntriesUpdateColumnUserID, FieldEntriesUpdateColumnValue:
		return true
	}
	return false
}

func (e FieldEntriesUpdateColumn) String() string {
	return string(e)
}

func (e *FieldEntriesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldEntriesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid field_entries_update_column", str)
	}
	return nil
}

func (e FieldEntriesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "fields"
type FieldsConstraint string

const (
	// unique or primary key constraint
	FieldsConstraintFieldsPkey FieldsConstraint = "fields_pkey"
)

var AllFieldsConstraint = []FieldsConstraint{
	FieldsConstraintFieldsPkey,
}

func (e FieldsConstraint) IsValid() bool {
	switch e {
	case FieldsConstraintFieldsPkey:
		return true
	}
	return false
}

func (e FieldsConstraint) String() string {
	return string(e)
}

func (e *FieldsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid fields_constraint", str)
	}
	return nil
}

func (e FieldsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "fields"
type FieldsSelectColumn string

const (
	// column name
	FieldsSelectColumnDescription FieldsSelectColumn = "description"
	// column name
	FieldsSelectColumnEditable FieldsSelectColumn = "editable"
	// column name
	FieldsSelectColumnFieldType FieldsSelectColumn = "field_type"
	// column name
	FieldsSelectColumnID FieldsSelectColumn = "id"
	// column name
	FieldsSelectColumnName FieldsSelectColumn = "name"
	// column name
	FieldsSelectColumnPublic FieldsSelectColumn = "public"
	// column name
	FieldsSelectColumnRequired FieldsSelectColumn = "required"
	// column name
	FieldsSelectColumnType FieldsSelectColumn = "type"
)

var AllFieldsSelectColumn = []FieldsSelectColumn{
	FieldsSelectColumnDescription,
	FieldsSelectColumnEditable,
	FieldsSelectColumnFieldType,
	FieldsSelectColumnID,
	FieldsSelectColumnName,
	FieldsSelectColumnPublic,
	FieldsSelectColumnRequired,
	FieldsSelectColumnType,
}

func (e FieldsSelectColumn) IsValid() bool {
	switch e {
	case FieldsSelectColumnDescription, FieldsSelectColumnEditable, FieldsSelectColumnFieldType, FieldsSelectColumnID, FieldsSelectColumnName, FieldsSelectColumnPublic, FieldsSelectColumnRequired, FieldsSelectColumnType:
		return true
	}
	return false
}

func (e FieldsSelectColumn) String() string {
	return string(e)
}

func (e *FieldsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid fields_select_column", str)
	}
	return nil
}

func (e FieldsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "fields"
type FieldsUpdateColumn string

const (
	// column name
	FieldsUpdateColumnDescription FieldsUpdateColumn = "description"
	// column name
	FieldsUpdateColumnEditable FieldsUpdateColumn = "editable"
	// column name
	FieldsUpdateColumnFieldType FieldsUpdateColumn = "field_type"
	// column name
	FieldsUpdateColumnID FieldsUpdateColumn = "id"
	// column name
	FieldsUpdateColumnName FieldsUpdateColumn = "name"
	// column name
	FieldsUpdateColumnPublic FieldsUpdateColumn = "public"
	// column name
	FieldsUpdateColumnRequired FieldsUpdateColumn = "required"
	// column name
	FieldsUpdateColumnType FieldsUpdateColumn = "type"
)

var AllFieldsUpdateColumn = []FieldsUpdateColumn{
	FieldsUpdateColumnDescription,
	FieldsUpdateColumnEditable,
	FieldsUpdateColumnFieldType,
	FieldsUpdateColumnID,
	FieldsUpdateColumnName,
	FieldsUpdateColumnPublic,
	FieldsUpdateColumnRequired,
	FieldsUpdateColumnType,
}

func (e FieldsUpdateColumn) IsValid() bool {
	switch e {
	case FieldsUpdateColumnDescription, FieldsUpdateColumnEditable, FieldsUpdateColumnFieldType, FieldsUpdateColumnID, FieldsUpdateColumnName, FieldsUpdateColumnPublic, FieldsUpdateColumnRequired, FieldsUpdateColumnType:
		return true
	}
	return false
}

func (e FieldsUpdateColumn) String() string {
	return string(e)
}

func (e *FieldsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid fields_update_column", str)
	}
	return nil
}

func (e FieldsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "files"
type FilesConstraint string

const (
	// unique or primary key constraint
	FilesConstraintFilesPkey FilesConstraint = "files_pkey"
)

var AllFilesConstraint = []FilesConstraint{
	FilesConstraintFilesPkey,
}

func (e FilesConstraint) IsValid() bool {
	switch e {
	case FilesConstraintFilesPkey:
		return true
	}
	return false
}

func (e FilesConstraint) String() string {
	return string(e)
}

func (e *FilesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid files_constraint", str)
	}
	return nil
}

func (e FilesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "files"
type FilesSelectColumn string

const (
	// column name
	FilesSelectColumnChallengeID FilesSelectColumn = "challenge_id"
	// column name
	FilesSelectColumnID FilesSelectColumn = "id"
	// column name
	FilesSelectColumnLocation FilesSelectColumn = "location"
	// column name
	FilesSelectColumnPageID FilesSelectColumn = "page_id"
	// column name
	FilesSelectColumnType FilesSelectColumn = "type"
)

var AllFilesSelectColumn = []FilesSelectColumn{
	FilesSelectColumnChallengeID,
	FilesSelectColumnID,
	FilesSelectColumnLocation,
	FilesSelectColumnPageID,
	FilesSelectColumnType,
}

func (e FilesSelectColumn) IsValid() bool {
	switch e {
	case FilesSelectColumnChallengeID, FilesSelectColumnID, FilesSelectColumnLocation, FilesSelectColumnPageID, FilesSelectColumnType:
		return true
	}
	return false
}

func (e FilesSelectColumn) String() string {
	return string(e)
}

func (e *FilesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid files_select_column", str)
	}
	return nil
}

func (e FilesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "files"
type FilesUpdateColumn string

const (
	// column name
	FilesUpdateColumnChallengeID FilesUpdateColumn = "challenge_id"
	// column name
	FilesUpdateColumnID FilesUpdateColumn = "id"
	// column name
	FilesUpdateColumnLocation FilesUpdateColumn = "location"
	// column name
	FilesUpdateColumnPageID FilesUpdateColumn = "page_id"
	// column name
	FilesUpdateColumnType FilesUpdateColumn = "type"
)

var AllFilesUpdateColumn = []FilesUpdateColumn{
	FilesUpdateColumnChallengeID,
	FilesUpdateColumnID,
	FilesUpdateColumnLocation,
	FilesUpdateColumnPageID,
	FilesUpdateColumnType,
}

func (e FilesUpdateColumn) IsValid() bool {
	switch e {
	case FilesUpdateColumnChallengeID, FilesUpdateColumnID, FilesUpdateColumnLocation, FilesUpdateColumnPageID, FilesUpdateColumnType:
		return true
	}
	return false
}

func (e FilesUpdateColumn) String() string {
	return string(e)
}

func (e *FilesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid files_update_column", str)
	}
	return nil
}

func (e FilesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "flags"
type FlagsConstraint string

const (
	// unique or primary key constraint
	FlagsConstraintFlagsPkey FlagsConstraint = "flags_pkey"
)

var AllFlagsConstraint = []FlagsConstraint{
	FlagsConstraintFlagsPkey,
}

func (e FlagsConstraint) IsValid() bool {
	switch e {
	case FlagsConstraintFlagsPkey:
		return true
	}
	return false
}

func (e FlagsConstraint) String() string {
	return string(e)
}

func (e *FlagsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FlagsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid flags_constraint", str)
	}
	return nil
}

func (e FlagsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "flags"
type FlagsSelectColumn string

const (
	// column name
	FlagsSelectColumnChallengeID FlagsSelectColumn = "challenge_id"
	// column name
	FlagsSelectColumnContent FlagsSelectColumn = "content"
	// column name
	FlagsSelectColumnData FlagsSelectColumn = "data"
	// column name
	FlagsSelectColumnID FlagsSelectColumn = "id"
	// column name
	FlagsSelectColumnType FlagsSelectColumn = "type"
)

var AllFlagsSelectColumn = []FlagsSelectColumn{
	FlagsSelectColumnChallengeID,
	FlagsSelectColumnContent,
	FlagsSelectColumnData,
	FlagsSelectColumnID,
	FlagsSelectColumnType,
}

func (e FlagsSelectColumn) IsValid() bool {
	switch e {
	case FlagsSelectColumnChallengeID, FlagsSelectColumnContent, FlagsSelectColumnData, FlagsSelectColumnID, FlagsSelectColumnType:
		return true
	}
	return false
}

func (e FlagsSelectColumn) String() string {
	return string(e)
}

func (e *FlagsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FlagsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid flags_select_column", str)
	}
	return nil
}

func (e FlagsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "flags"
type FlagsUpdateColumn string

const (
	// column name
	FlagsUpdateColumnChallengeID FlagsUpdateColumn = "challenge_id"
	// column name
	FlagsUpdateColumnContent FlagsUpdateColumn = "content"
	// column name
	FlagsUpdateColumnData FlagsUpdateColumn = "data"
	// column name
	FlagsUpdateColumnID FlagsUpdateColumn = "id"
	// column name
	FlagsUpdateColumnType FlagsUpdateColumn = "type"
)

var AllFlagsUpdateColumn = []FlagsUpdateColumn{
	FlagsUpdateColumnChallengeID,
	FlagsUpdateColumnContent,
	FlagsUpdateColumnData,
	FlagsUpdateColumnID,
	FlagsUpdateColumnType,
}

func (e FlagsUpdateColumn) IsValid() bool {
	switch e {
	case FlagsUpdateColumnChallengeID, FlagsUpdateColumnContent, FlagsUpdateColumnData, FlagsUpdateColumnID, FlagsUpdateColumnType:
		return true
	}
	return false
}

func (e FlagsUpdateColumn) String() string {
	return string(e)
}

func (e *FlagsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FlagsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid flags_update_column", str)
	}
	return nil
}

func (e FlagsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "hints"
type HintsConstraint string

const (
	// unique or primary key constraint
	HintsConstraintHintsPkey HintsConstraint = "hints_pkey"
)

var AllHintsConstraint = []HintsConstraint{
	HintsConstraintHintsPkey,
}

func (e HintsConstraint) IsValid() bool {
	switch e {
	case HintsConstraintHintsPkey:
		return true
	}
	return false
}

func (e HintsConstraint) String() string {
	return string(e)
}

func (e *HintsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HintsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid hints_constraint", str)
	}
	return nil
}

func (e HintsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "hints_content"
type HintsContentSelectColumn string

const (
	// column name
	HintsContentSelectColumnContent HintsContentSelectColumn = "content"
	// column name
	HintsContentSelectColumnID HintsContentSelectColumn = "id"
)

var AllHintsContentSelectColumn = []HintsContentSelectColumn{
	HintsContentSelectColumnContent,
	HintsContentSelectColumnID,
}

func (e HintsContentSelectColumn) IsValid() bool {
	switch e {
	case HintsContentSelectColumnContent, HintsContentSelectColumnID:
		return true
	}
	return false
}

func (e HintsContentSelectColumn) String() string {
	return string(e)
}

func (e *HintsContentSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HintsContentSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid hints_content_select_column", str)
	}
	return nil
}

func (e HintsContentSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "hints"
type HintsSelectColumn string

const (
	// column name
	HintsSelectColumnChallengeID HintsSelectColumn = "challenge_id"
	// column name
	HintsSelectColumnContent HintsSelectColumn = "content"
	// column name
	HintsSelectColumnCost HintsSelectColumn = "cost"
	// column name
	HintsSelectColumnID HintsSelectColumn = "id"
	// column name
	HintsSelectColumnRequirements HintsSelectColumn = "requirements"
	// column name
	HintsSelectColumnType HintsSelectColumn = "type"
)

var AllHintsSelectColumn = []HintsSelectColumn{
	HintsSelectColumnChallengeID,
	HintsSelectColumnContent,
	HintsSelectColumnCost,
	HintsSelectColumnID,
	HintsSelectColumnRequirements,
	HintsSelectColumnType,
}

func (e HintsSelectColumn) IsValid() bool {
	switch e {
	case HintsSelectColumnChallengeID, HintsSelectColumnContent, HintsSelectColumnCost, HintsSelectColumnID, HintsSelectColumnRequirements, HintsSelectColumnType:
		return true
	}
	return false
}

func (e HintsSelectColumn) String() string {
	return string(e)
}

func (e *HintsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HintsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid hints_select_column", str)
	}
	return nil
}

func (e HintsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "hints"
type HintsUpdateColumn string

const (
	// column name
	HintsUpdateColumnChallengeID HintsUpdateColumn = "challenge_id"
	// column name
	HintsUpdateColumnContent HintsUpdateColumn = "content"
	// column name
	HintsUpdateColumnCost HintsUpdateColumn = "cost"
	// column name
	HintsUpdateColumnID HintsUpdateColumn = "id"
	// column name
	HintsUpdateColumnRequirements HintsUpdateColumn = "requirements"
	// column name
	HintsUpdateColumnType HintsUpdateColumn = "type"
)

var AllHintsUpdateColumn = []HintsUpdateColumn{
	HintsUpdateColumnChallengeID,
	HintsUpdateColumnContent,
	HintsUpdateColumnCost,
	HintsUpdateColumnID,
	HintsUpdateColumnRequirements,
	HintsUpdateColumnType,
}

func (e HintsUpdateColumn) IsValid() bool {
	switch e {
	case HintsUpdateColumnChallengeID, HintsUpdateColumnContent, HintsUpdateColumnCost, HintsUpdateColumnID, HintsUpdateColumnRequirements, HintsUpdateColumnType:
		return true
	}
	return false
}

func (e HintsUpdateColumn) String() string {
	return string(e)
}

func (e *HintsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HintsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid hints_update_column", str)
	}
	return nil
}

func (e HintsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "notifications"
type NotificationsConstraint string

const (
	// unique or primary key constraint
	NotificationsConstraintNotificationsPkey NotificationsConstraint = "notifications_pkey"
)

var AllNotificationsConstraint = []NotificationsConstraint{
	NotificationsConstraintNotificationsPkey,
}

func (e NotificationsConstraint) IsValid() bool {
	switch e {
	case NotificationsConstraintNotificationsPkey:
		return true
	}
	return false
}

func (e NotificationsConstraint) String() string {
	return string(e)
}

func (e *NotificationsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid notifications_constraint", str)
	}
	return nil
}

func (e NotificationsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "notifications"
type NotificationsSelectColumn string

const (
	// column name
	NotificationsSelectColumnContent NotificationsSelectColumn = "content"
	// column name
	NotificationsSelectColumnDate NotificationsSelectColumn = "date"
	// column name
	NotificationsSelectColumnID NotificationsSelectColumn = "id"
	// column name
	NotificationsSelectColumnTeamID NotificationsSelectColumn = "team_id"
	// column name
	NotificationsSelectColumnTitle NotificationsSelectColumn = "title"
	// column name
	NotificationsSelectColumnUserID NotificationsSelectColumn = "user_id"
)

var AllNotificationsSelectColumn = []NotificationsSelectColumn{
	NotificationsSelectColumnContent,
	NotificationsSelectColumnDate,
	NotificationsSelectColumnID,
	NotificationsSelectColumnTeamID,
	NotificationsSelectColumnTitle,
	NotificationsSelectColumnUserID,
}

func (e NotificationsSelectColumn) IsValid() bool {
	switch e {
	case NotificationsSelectColumnContent, NotificationsSelectColumnDate, NotificationsSelectColumnID, NotificationsSelectColumnTeamID, NotificationsSelectColumnTitle, NotificationsSelectColumnUserID:
		return true
	}
	return false
}

func (e NotificationsSelectColumn) String() string {
	return string(e)
}

func (e *NotificationsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid notifications_select_column", str)
	}
	return nil
}

func (e NotificationsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "notifications"
type NotificationsUpdateColumn string

const (
	// column name
	NotificationsUpdateColumnContent NotificationsUpdateColumn = "content"
	// column name
	NotificationsUpdateColumnDate NotificationsUpdateColumn = "date"
	// column name
	NotificationsUpdateColumnID NotificationsUpdateColumn = "id"
	// column name
	NotificationsUpdateColumnTeamID NotificationsUpdateColumn = "team_id"
	// column name
	NotificationsUpdateColumnTitle NotificationsUpdateColumn = "title"
	// column name
	NotificationsUpdateColumnUserID NotificationsUpdateColumn = "user_id"
)

var AllNotificationsUpdateColumn = []NotificationsUpdateColumn{
	NotificationsUpdateColumnContent,
	NotificationsUpdateColumnDate,
	NotificationsUpdateColumnID,
	NotificationsUpdateColumnTeamID,
	NotificationsUpdateColumnTitle,
	NotificationsUpdateColumnUserID,
}

func (e NotificationsUpdateColumn) IsValid() bool {
	switch e {
	case NotificationsUpdateColumnContent, NotificationsUpdateColumnDate, NotificationsUpdateColumnID, NotificationsUpdateColumnTeamID, NotificationsUpdateColumnTitle, NotificationsUpdateColumnUserID:
		return true
	}
	return false
}

func (e NotificationsUpdateColumn) String() string {
	return string(e)
}

func (e *NotificationsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid notifications_update_column", str)
	}
	return nil
}

func (e NotificationsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// column ordering options
type OrderBy string

const (
	// in ascending order, nulls last
	OrderByAsc OrderBy = "asc"
	// in ascending order, nulls first
	OrderByAscNullsFirst OrderBy = "asc_nulls_first"
	// in ascending order, nulls last
	OrderByAscNullsLast OrderBy = "asc_nulls_last"
	// in descending order, nulls first
	OrderByDesc OrderBy = "desc"
	// in descending order, nulls first
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	// in descending order, nulls last
	OrderByDescNullsLast OrderBy = "desc_nulls_last"
)

var AllOrderBy = []OrderBy{
	OrderByAsc,
	OrderByAscNullsFirst,
	OrderByAscNullsLast,
	OrderByDesc,
	OrderByDescNullsFirst,
	OrderByDescNullsLast,
}

func (e OrderBy) IsValid() bool {
	switch e {
	case OrderByAsc, OrderByAscNullsFirst, OrderByAscNullsLast, OrderByDesc, OrderByDescNullsFirst, OrderByDescNullsLast:
		return true
	}
	return false
}

func (e OrderBy) String() string {
	return string(e)
}

func (e *OrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_by", str)
	}
	return nil
}

func (e OrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "pages"
type PagesConstraint string

const (
	// unique or primary key constraint
	PagesConstraintPagesPkey PagesConstraint = "pages_pkey"
	// unique or primary key constraint
	PagesConstraintPagesRouteKey PagesConstraint = "pages_route_key"
)

var AllPagesConstraint = []PagesConstraint{
	PagesConstraintPagesPkey,
	PagesConstraintPagesRouteKey,
}

func (e PagesConstraint) IsValid() bool {
	switch e {
	case PagesConstraintPagesPkey, PagesConstraintPagesRouteKey:
		return true
	}
	return false
}

func (e PagesConstraint) String() string {
	return string(e)
}

func (e *PagesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PagesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid pages_constraint", str)
	}
	return nil
}

func (e PagesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "pages"
type PagesSelectColumn string

const (
	// column name
	PagesSelectColumnAuthRequired PagesSelectColumn = "auth_required"
	// column name
	PagesSelectColumnContent PagesSelectColumn = "content"
	// column name
	PagesSelectColumnDraft PagesSelectColumn = "draft"
	// column name
	PagesSelectColumnFormat PagesSelectColumn = "format"
	// column name
	PagesSelectColumnHidden PagesSelectColumn = "hidden"
	// column name
	PagesSelectColumnID PagesSelectColumn = "id"
	// column name
	PagesSelectColumnRoute PagesSelectColumn = "route"
	// column name
	PagesSelectColumnTitle PagesSelectColumn = "title"
)

var AllPagesSelectColumn = []PagesSelectColumn{
	PagesSelectColumnAuthRequired,
	PagesSelectColumnContent,
	PagesSelectColumnDraft,
	PagesSelectColumnFormat,
	PagesSelectColumnHidden,
	PagesSelectColumnID,
	PagesSelectColumnRoute,
	PagesSelectColumnTitle,
}

func (e PagesSelectColumn) IsValid() bool {
	switch e {
	case PagesSelectColumnAuthRequired, PagesSelectColumnContent, PagesSelectColumnDraft, PagesSelectColumnFormat, PagesSelectColumnHidden, PagesSelectColumnID, PagesSelectColumnRoute, PagesSelectColumnTitle:
		return true
	}
	return false
}

func (e PagesSelectColumn) String() string {
	return string(e)
}

func (e *PagesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PagesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid pages_select_column", str)
	}
	return nil
}

func (e PagesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "pages"
type PagesUpdateColumn string

const (
	// column name
	PagesUpdateColumnAuthRequired PagesUpdateColumn = "auth_required"
	// column name
	PagesUpdateColumnContent PagesUpdateColumn = "content"
	// column name
	PagesUpdateColumnDraft PagesUpdateColumn = "draft"
	// column name
	PagesUpdateColumnFormat PagesUpdateColumn = "format"
	// column name
	PagesUpdateColumnHidden PagesUpdateColumn = "hidden"
	// column name
	PagesUpdateColumnID PagesUpdateColumn = "id"
	// column name
	PagesUpdateColumnRoute PagesUpdateColumn = "route"
	// column name
	PagesUpdateColumnTitle PagesUpdateColumn = "title"
)

var AllPagesUpdateColumn = []PagesUpdateColumn{
	PagesUpdateColumnAuthRequired,
	PagesUpdateColumnContent,
	PagesUpdateColumnDraft,
	PagesUpdateColumnFormat,
	PagesUpdateColumnHidden,
	PagesUpdateColumnID,
	PagesUpdateColumnRoute,
	PagesUpdateColumnTitle,
}

func (e PagesUpdateColumn) IsValid() bool {
	switch e {
	case PagesUpdateColumnAuthRequired, PagesUpdateColumnContent, PagesUpdateColumnDraft, PagesUpdateColumnFormat, PagesUpdateColumnHidden, PagesUpdateColumnID, PagesUpdateColumnRoute, PagesUpdateColumnTitle:
		return true
	}
	return false
}

func (e PagesUpdateColumn) String() string {
	return string(e)
}

func (e *PagesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PagesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid pages_update_column", str)
	}
	return nil
}

func (e PagesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "score_events"
type ScoreEventsConstraint string

const (
	// unique or primary key constraint
	ScoreEventsConstraintScoreEventsAllUniqIdx ScoreEventsConstraint = "score_events_all_uniq_idx"
)

var AllScoreEventsConstraint = []ScoreEventsConstraint{
	ScoreEventsConstraintScoreEventsAllUniqIdx,
}

func (e ScoreEventsConstraint) IsValid() bool {
	switch e {
	case ScoreEventsConstraintScoreEventsAllUniqIdx:
		return true
	}
	return false
}

func (e ScoreEventsConstraint) String() string {
	return string(e)
}

func (e *ScoreEventsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreEventsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid score_events_constraint", str)
	}
	return nil
}

func (e ScoreEventsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "score_events"
type ScoreEventsSelectColumn string

const (
	// column name
	ScoreEventsSelectColumnEventTime ScoreEventsSelectColumn = "event_time"
	// column name
	ScoreEventsSelectColumnEventValue ScoreEventsSelectColumn = "event_value"
	// column name
	ScoreEventsSelectColumnTeamID ScoreEventsSelectColumn = "team_id"
	// column name
	ScoreEventsSelectColumnUserID ScoreEventsSelectColumn = "user_id"
)

var AllScoreEventsSelectColumn = []ScoreEventsSelectColumn{
	ScoreEventsSelectColumnEventTime,
	ScoreEventsSelectColumnEventValue,
	ScoreEventsSelectColumnTeamID,
	ScoreEventsSelectColumnUserID,
}

func (e ScoreEventsSelectColumn) IsValid() bool {
	switch e {
	case ScoreEventsSelectColumnEventTime, ScoreEventsSelectColumnEventValue, ScoreEventsSelectColumnTeamID, ScoreEventsSelectColumnUserID:
		return true
	}
	return false
}

func (e ScoreEventsSelectColumn) String() string {
	return string(e)
}

func (e *ScoreEventsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreEventsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid score_events_select_column", str)
	}
	return nil
}

func (e ScoreEventsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "score_events"
type ScoreEventsUpdateColumn string

const (
	// column name
	ScoreEventsUpdateColumnEventTime ScoreEventsUpdateColumn = "event_time"
	// column name
	ScoreEventsUpdateColumnEventValue ScoreEventsUpdateColumn = "event_value"
	// column name
	ScoreEventsUpdateColumnTeamID ScoreEventsUpdateColumn = "team_id"
	// column name
	ScoreEventsUpdateColumnUserID ScoreEventsUpdateColumn = "user_id"
)

var AllScoreEventsUpdateColumn = []ScoreEventsUpdateColumn{
	ScoreEventsUpdateColumnEventTime,
	ScoreEventsUpdateColumnEventValue,
	ScoreEventsUpdateColumnTeamID,
	ScoreEventsUpdateColumnUserID,
}

func (e ScoreEventsUpdateColumn) IsValid() bool {
	switch e {
	case ScoreEventsUpdateColumnEventTime, ScoreEventsUpdateColumnEventValue, ScoreEventsUpdateColumnTeamID, ScoreEventsUpdateColumnUserID:
		return true
	}
	return false
}

func (e ScoreEventsUpdateColumn) String() string {
	return string(e)
}

func (e *ScoreEventsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreEventsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid score_events_update_column", str)
	}
	return nil
}

func (e ScoreEventsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "score_timeline"
type ScoreTimelineSelectColumn string

const (
	// column name
	ScoreTimelineSelectColumnEventTime ScoreTimelineSelectColumn = "event_time"
	// column name
	ScoreTimelineSelectColumnScore ScoreTimelineSelectColumn = "score"
	// column name
	ScoreTimelineSelectColumnTeamID ScoreTimelineSelectColumn = "team_id"
)

var AllScoreTimelineSelectColumn = []ScoreTimelineSelectColumn{
	ScoreTimelineSelectColumnEventTime,
	ScoreTimelineSelectColumnScore,
	ScoreTimelineSelectColumnTeamID,
}

func (e ScoreTimelineSelectColumn) IsValid() bool {
	switch e {
	case ScoreTimelineSelectColumnEventTime, ScoreTimelineSelectColumnScore, ScoreTimelineSelectColumnTeamID:
		return true
	}
	return false
}

func (e ScoreTimelineSelectColumn) String() string {
	return string(e)
}

func (e *ScoreTimelineSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreTimelineSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid score_timeline_select_column", str)
	}
	return nil
}

func (e ScoreTimelineSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "score_timeline_user"
type ScoreTimelineUserSelectColumn string

const (
	// column name
	ScoreTimelineUserSelectColumnEventTime ScoreTimelineUserSelectColumn = "event_time"
	// column name
	ScoreTimelineUserSelectColumnScore ScoreTimelineUserSelectColumn = "score"
	// column name
	ScoreTimelineUserSelectColumnTeamID ScoreTimelineUserSelectColumn = "team_id"
	// column name
	ScoreTimelineUserSelectColumnUserID ScoreTimelineUserSelectColumn = "user_id"
)

var AllScoreTimelineUserSelectColumn = []ScoreTimelineUserSelectColumn{
	ScoreTimelineUserSelectColumnEventTime,
	ScoreTimelineUserSelectColumnScore,
	ScoreTimelineUserSelectColumnTeamID,
	ScoreTimelineUserSelectColumnUserID,
}

func (e ScoreTimelineUserSelectColumn) IsValid() bool {
	switch e {
	case ScoreTimelineUserSelectColumnEventTime, ScoreTimelineUserSelectColumnScore, ScoreTimelineUserSelectColumnTeamID, ScoreTimelineUserSelectColumnUserID:
		return true
	}
	return false
}

func (e ScoreTimelineUserSelectColumn) String() string {
	return string(e)
}

func (e *ScoreTimelineUserSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreTimelineUserSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid score_timeline_user_select_column", str)
	}
	return nil
}

func (e ScoreTimelineUserSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "scoreboard"
type ScoreboardSelectColumn string

const (
	// column name
	ScoreboardSelectColumnMaxTime ScoreboardSelectColumn = "max_time"
	// column name
	ScoreboardSelectColumnRank ScoreboardSelectColumn = "rank"
	// column name
	ScoreboardSelectColumnScore ScoreboardSelectColumn = "score"
	// column name
	ScoreboardSelectColumnTeamID ScoreboardSelectColumn = "team_id"
)

var AllScoreboardSelectColumn = []ScoreboardSelectColumn{
	ScoreboardSelectColumnMaxTime,
	ScoreboardSelectColumnRank,
	ScoreboardSelectColumnScore,
	ScoreboardSelectColumnTeamID,
}

func (e ScoreboardSelectColumn) IsValid() bool {
	switch e {
	case ScoreboardSelectColumnMaxTime, ScoreboardSelectColumnRank, ScoreboardSelectColumnScore, ScoreboardSelectColumnTeamID:
		return true
	}
	return false
}

func (e ScoreboardSelectColumn) String() string {
	return string(e)
}

func (e *ScoreboardSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreboardSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid scoreboard_select_column", str)
	}
	return nil
}

func (e ScoreboardSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "scoreboard_user"
type ScoreboardUserSelectColumn string

const (
	// column name
	ScoreboardUserSelectColumnMaxTime ScoreboardUserSelectColumn = "max_time"
	// column name
	ScoreboardUserSelectColumnRank ScoreboardUserSelectColumn = "rank"
	// column name
	ScoreboardUserSelectColumnScore ScoreboardUserSelectColumn = "score"
	// column name
	ScoreboardUserSelectColumnTeamID ScoreboardUserSelectColumn = "team_id"
	// column name
	ScoreboardUserSelectColumnUserID ScoreboardUserSelectColumn = "user_id"
)

var AllScoreboardUserSelectColumn = []ScoreboardUserSelectColumn{
	ScoreboardUserSelectColumnMaxTime,
	ScoreboardUserSelectColumnRank,
	ScoreboardUserSelectColumnScore,
	ScoreboardUserSelectColumnTeamID,
	ScoreboardUserSelectColumnUserID,
}

func (e ScoreboardUserSelectColumn) IsValid() bool {
	switch e {
	case ScoreboardUserSelectColumnMaxTime, ScoreboardUserSelectColumnRank, ScoreboardUserSelectColumnScore, ScoreboardUserSelectColumnTeamID, ScoreboardUserSelectColumnUserID:
		return true
	}
	return false
}

func (e ScoreboardUserSelectColumn) String() string {
	return string(e)
}

func (e *ScoreboardUserSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreboardUserSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid scoreboard_user_select_column", str)
	}
	return nil
}

func (e ScoreboardUserSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "solves"
type SolvesConstraint string

const (
	// unique or primary key constraint
	SolvesConstraintSolvesChallengeIDTeamIDKey SolvesConstraint = "solves_challenge_id_team_id_key"
	// unique or primary key constraint
	SolvesConstraintSolvesChallengeIDUserIDKey SolvesConstraint = "solves_challenge_id_user_id_key"
	// unique or primary key constraint
	SolvesConstraintSolvesPkey SolvesConstraint = "solves_pkey"
)

var AllSolvesConstraint = []SolvesConstraint{
	SolvesConstraintSolvesChallengeIDTeamIDKey,
	SolvesConstraintSolvesChallengeIDUserIDKey,
	SolvesConstraintSolvesPkey,
}

func (e SolvesConstraint) IsValid() bool {
	switch e {
	case SolvesConstraintSolvesChallengeIDTeamIDKey, SolvesConstraintSolvesChallengeIDUserIDKey, SolvesConstraintSolvesPkey:
		return true
	}
	return false
}

func (e SolvesConstraint) String() string {
	return string(e)
}

func (e *SolvesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolvesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid solves_constraint", str)
	}
	return nil
}

func (e SolvesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "solves"
type SolvesSelectColumn string

const (
	// column name
	SolvesSelectColumnChallengeID SolvesSelectColumn = "challenge_id"
	// column name
	SolvesSelectColumnID SolvesSelectColumn = "id"
	// column name
	SolvesSelectColumnTeamID SolvesSelectColumn = "team_id"
	// column name
	SolvesSelectColumnUserID SolvesSelectColumn = "user_id"
)

var AllSolvesSelectColumn = []SolvesSelectColumn{
	SolvesSelectColumnChallengeID,
	SolvesSelectColumnID,
	SolvesSelectColumnTeamID,
	SolvesSelectColumnUserID,
}

func (e SolvesSelectColumn) IsValid() bool {
	switch e {
	case SolvesSelectColumnChallengeID, SolvesSelectColumnID, SolvesSelectColumnTeamID, SolvesSelectColumnUserID:
		return true
	}
	return false
}

func (e SolvesSelectColumn) String() string {
	return string(e)
}

func (e *SolvesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolvesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid solves_select_column", str)
	}
	return nil
}

func (e SolvesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "solves"
type SolvesUpdateColumn string

const (
	// column name
	SolvesUpdateColumnChallengeID SolvesUpdateColumn = "challenge_id"
	// column name
	SolvesUpdateColumnID SolvesUpdateColumn = "id"
	// column name
	SolvesUpdateColumnTeamID SolvesUpdateColumn = "team_id"
	// column name
	SolvesUpdateColumnUserID SolvesUpdateColumn = "user_id"
)

var AllSolvesUpdateColumn = []SolvesUpdateColumn{
	SolvesUpdateColumnChallengeID,
	SolvesUpdateColumnID,
	SolvesUpdateColumnTeamID,
	SolvesUpdateColumnUserID,
}

func (e SolvesUpdateColumn) IsValid() bool {
	switch e {
	case SolvesUpdateColumnChallengeID, SolvesUpdateColumnID, SolvesUpdateColumnTeamID, SolvesUpdateColumnUserID:
		return true
	}
	return false
}

func (e SolvesUpdateColumn) String() string {
	return string(e)
}

func (e *SolvesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolvesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid solves_update_column", str)
	}
	return nil
}

func (e SolvesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "submissions"
type SubmissionsConstraint string

const (
	// unique or primary key constraint
	SubmissionsConstraintSubmissionsPkey SubmissionsConstraint = "submissions_pkey"
)

var AllSubmissionsConstraint = []SubmissionsConstraint{
	SubmissionsConstraintSubmissionsPkey,
}

func (e SubmissionsConstraint) IsValid() bool {
	switch e {
	case SubmissionsConstraintSubmissionsPkey:
		return true
	}
	return false
}

func (e SubmissionsConstraint) String() string {
	return string(e)
}

func (e *SubmissionsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid submissions_constraint", str)
	}
	return nil
}

func (e SubmissionsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "submissions"
type SubmissionsSelectColumn string

const (
	// column name
	SubmissionsSelectColumnChallengeID SubmissionsSelectColumn = "challenge_id"
	// column name
	SubmissionsSelectColumnDate SubmissionsSelectColumn = "date"
	// column name
	SubmissionsSelectColumnID SubmissionsSelectColumn = "id"
	// column name
	SubmissionsSelectColumnIP SubmissionsSelectColumn = "ip"
	// column name
	SubmissionsSelectColumnProvided SubmissionsSelectColumn = "provided"
	// column name
	SubmissionsSelectColumnTeamID SubmissionsSelectColumn = "team_id"
	// column name
	SubmissionsSelectColumnType SubmissionsSelectColumn = "type"
	// column name
	SubmissionsSelectColumnUserID SubmissionsSelectColumn = "user_id"
)

var AllSubmissionsSelectColumn = []SubmissionsSelectColumn{
	SubmissionsSelectColumnChallengeID,
	SubmissionsSelectColumnDate,
	SubmissionsSelectColumnID,
	SubmissionsSelectColumnIP,
	SubmissionsSelectColumnProvided,
	SubmissionsSelectColumnTeamID,
	SubmissionsSelectColumnType,
	SubmissionsSelectColumnUserID,
}

func (e SubmissionsSelectColumn) IsValid() bool {
	switch e {
	case SubmissionsSelectColumnChallengeID, SubmissionsSelectColumnDate, SubmissionsSelectColumnID, SubmissionsSelectColumnIP, SubmissionsSelectColumnProvided, SubmissionsSelectColumnTeamID, SubmissionsSelectColumnType, SubmissionsSelectColumnUserID:
		return true
	}
	return false
}

func (e SubmissionsSelectColumn) String() string {
	return string(e)
}

func (e *SubmissionsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid submissions_select_column", str)
	}
	return nil
}

func (e SubmissionsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "submissions"
type SubmissionsUpdateColumn string

const (
	// column name
	SubmissionsUpdateColumnChallengeID SubmissionsUpdateColumn = "challenge_id"
	// column name
	SubmissionsUpdateColumnDate SubmissionsUpdateColumn = "date"
	// column name
	SubmissionsUpdateColumnID SubmissionsUpdateColumn = "id"
	// column name
	SubmissionsUpdateColumnIP SubmissionsUpdateColumn = "ip"
	// column name
	SubmissionsUpdateColumnProvided SubmissionsUpdateColumn = "provided"
	// column name
	SubmissionsUpdateColumnTeamID SubmissionsUpdateColumn = "team_id"
	// column name
	SubmissionsUpdateColumnType SubmissionsUpdateColumn = "type"
	// column name
	SubmissionsUpdateColumnUserID SubmissionsUpdateColumn = "user_id"
)

var AllSubmissionsUpdateColumn = []SubmissionsUpdateColumn{
	SubmissionsUpdateColumnChallengeID,
	SubmissionsUpdateColumnDate,
	SubmissionsUpdateColumnID,
	SubmissionsUpdateColumnIP,
	SubmissionsUpdateColumnProvided,
	SubmissionsUpdateColumnTeamID,
	SubmissionsUpdateColumnType,
	SubmissionsUpdateColumnUserID,
}

func (e SubmissionsUpdateColumn) IsValid() bool {
	switch e {
	case SubmissionsUpdateColumnChallengeID, SubmissionsUpdateColumnDate, SubmissionsUpdateColumnID, SubmissionsUpdateColumnIP, SubmissionsUpdateColumnProvided, SubmissionsUpdateColumnTeamID, SubmissionsUpdateColumnType, SubmissionsUpdateColumnUserID:
		return true
	}
	return false
}

func (e SubmissionsUpdateColumn) String() string {
	return string(e)
}

func (e *SubmissionsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid submissions_update_column", str)
	}
	return nil
}

func (e SubmissionsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "tags"
type TagsConstraint string

const (
	// unique or primary key constraint
	TagsConstraintTagsPkey TagsConstraint = "tags_pkey"
)

var AllTagsConstraint = []TagsConstraint{
	TagsConstraintTagsPkey,
}

func (e TagsConstraint) IsValid() bool {
	switch e {
	case TagsConstraintTagsPkey:
		return true
	}
	return false
}

func (e TagsConstraint) String() string {
	return string(e)
}

func (e *TagsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_constraint", str)
	}
	return nil
}

func (e TagsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "tags"
type TagsSelectColumn string

const (
	// column name
	TagsSelectColumnChallengeID TagsSelectColumn = "challenge_id"
	// column name
	TagsSelectColumnID TagsSelectColumn = "id"
	// column name
	TagsSelectColumnValue TagsSelectColumn = "value"
)

var AllTagsSelectColumn = []TagsSelectColumn{
	TagsSelectColumnChallengeID,
	TagsSelectColumnID,
	TagsSelectColumnValue,
}

func (e TagsSelectColumn) IsValid() bool {
	switch e {
	case TagsSelectColumnChallengeID, TagsSelectColumnID, TagsSelectColumnValue:
		return true
	}
	return false
}

func (e TagsSelectColumn) String() string {
	return string(e)
}

func (e *TagsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_select_column", str)
	}
	return nil
}

func (e TagsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "tags"
type TagsUpdateColumn string

const (
	// column name
	TagsUpdateColumnChallengeID TagsUpdateColumn = "challenge_id"
	// column name
	TagsUpdateColumnID TagsUpdateColumn = "id"
	// column name
	TagsUpdateColumnValue TagsUpdateColumn = "value"
)

var AllTagsUpdateColumn = []TagsUpdateColumn{
	TagsUpdateColumnChallengeID,
	TagsUpdateColumnID,
	TagsUpdateColumnValue,
}

func (e TagsUpdateColumn) IsValid() bool {
	switch e {
	case TagsUpdateColumnChallengeID, TagsUpdateColumnID, TagsUpdateColumnValue:
		return true
	}
	return false
}

func (e TagsUpdateColumn) String() string {
	return string(e)
}

func (e *TagsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tags_update_column", str)
	}
	return nil
}

func (e TagsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "teams"
type TeamsConstraint string

const (
	// unique or primary key constraint
	TeamsConstraintTeamsEmailKey TeamsConstraint = "teams_email_key"
	// unique or primary key constraint
	TeamsConstraintTeamsIDOauthIDKey TeamsConstraint = "teams_id_oauth_id_key"
	// unique or primary key constraint
	TeamsConstraintTeamsOauthIDKey TeamsConstraint = "teams_oauth_id_key"
	// unique or primary key constraint
	TeamsConstraintTeamsPkey TeamsConstraint = "teams_pkey"
)

var AllTeamsConstraint = []TeamsConstraint{
	TeamsConstraintTeamsEmailKey,
	TeamsConstraintTeamsIDOauthIDKey,
	TeamsConstraintTeamsOauthIDKey,
	TeamsConstraintTeamsPkey,
}

func (e TeamsConstraint) IsValid() bool {
	switch e {
	case TeamsConstraintTeamsEmailKey, TeamsConstraintTeamsIDOauthIDKey, TeamsConstraintTeamsOauthIDKey, TeamsConstraintTeamsPkey:
		return true
	}
	return false
}

func (e TeamsConstraint) String() string {
	return string(e)
}

func (e *TeamsConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid teams_constraint", str)
	}
	return nil
}

func (e TeamsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "teams"
type TeamsSelectColumn string

const (
	// column name
	TeamsSelectColumnAffiliation TeamsSelectColumn = "affiliation"
	// column name
	TeamsSelectColumnBanned TeamsSelectColumn = "banned"
	// column name
	TeamsSelectColumnBracket TeamsSelectColumn = "bracket"
	// column name
	TeamsSelectColumnCaptainID TeamsSelectColumn = "captain_id"
	// column name
	TeamsSelectColumnCountry TeamsSelectColumn = "country"
	// column name
	TeamsSelectColumnCreated TeamsSelectColumn = "created"
	// column name
	TeamsSelectColumnEmail TeamsSelectColumn = "email"
	// column name
	TeamsSelectColumnHidden TeamsSelectColumn = "hidden"
	// column name
	TeamsSelectColumnID TeamsSelectColumn = "id"
	// column name
	TeamsSelectColumnName TeamsSelectColumn = "name"
	// column name
	TeamsSelectColumnOauthID TeamsSelectColumn = "oauth_id"
	// column name
	TeamsSelectColumnPassword TeamsSelectColumn = "password"
	// column name
	TeamsSelectColumnSecret TeamsSelectColumn = "secret"
	// column name
	TeamsSelectColumnWebsite TeamsSelectColumn = "website"
)

var AllTeamsSelectColumn = []TeamsSelectColumn{
	TeamsSelectColumnAffiliation,
	TeamsSelectColumnBanned,
	TeamsSelectColumnBracket,
	TeamsSelectColumnCaptainID,
	TeamsSelectColumnCountry,
	TeamsSelectColumnCreated,
	TeamsSelectColumnEmail,
	TeamsSelectColumnHidden,
	TeamsSelectColumnID,
	TeamsSelectColumnName,
	TeamsSelectColumnOauthID,
	TeamsSelectColumnPassword,
	TeamsSelectColumnSecret,
	TeamsSelectColumnWebsite,
}

func (e TeamsSelectColumn) IsValid() bool {
	switch e {
	case TeamsSelectColumnAffiliation, TeamsSelectColumnBanned, TeamsSelectColumnBracket, TeamsSelectColumnCaptainID, TeamsSelectColumnCountry, TeamsSelectColumnCreated, TeamsSelectColumnEmail, TeamsSelectColumnHidden, TeamsSelectColumnID, TeamsSelectColumnName, TeamsSelectColumnOauthID, TeamsSelectColumnPassword, TeamsSelectColumnSecret, TeamsSelectColumnWebsite:
		return true
	}
	return false
}

func (e TeamsSelectColumn) String() string {
	return string(e)
}

func (e *TeamsSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid teams_select_column", str)
	}
	return nil
}

func (e TeamsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "teams"
type TeamsUpdateColumn string

const (
	// column name
	TeamsUpdateColumnAffiliation TeamsUpdateColumn = "affiliation"
	// column name
	TeamsUpdateColumnBanned TeamsUpdateColumn = "banned"
	// column name
	TeamsUpdateColumnBracket TeamsUpdateColumn = "bracket"
	// column name
	TeamsUpdateColumnCaptainID TeamsUpdateColumn = "captain_id"
	// column name
	TeamsUpdateColumnCountry TeamsUpdateColumn = "country"
	// column name
	TeamsUpdateColumnCreated TeamsUpdateColumn = "created"
	// column name
	TeamsUpdateColumnEmail TeamsUpdateColumn = "email"
	// column name
	TeamsUpdateColumnHidden TeamsUpdateColumn = "hidden"
	// column name
	TeamsUpdateColumnID TeamsUpdateColumn = "id"
	// column name
	TeamsUpdateColumnName TeamsUpdateColumn = "name"
	// column name
	TeamsUpdateColumnOauthID TeamsUpdateColumn = "oauth_id"
	// column name
	TeamsUpdateColumnPassword TeamsUpdateColumn = "password"
	// column name
	TeamsUpdateColumnSecret TeamsUpdateColumn = "secret"
	// column name
	TeamsUpdateColumnWebsite TeamsUpdateColumn = "website"
)

var AllTeamsUpdateColumn = []TeamsUpdateColumn{
	TeamsUpdateColumnAffiliation,
	TeamsUpdateColumnBanned,
	TeamsUpdateColumnBracket,
	TeamsUpdateColumnCaptainID,
	TeamsUpdateColumnCountry,
	TeamsUpdateColumnCreated,
	TeamsUpdateColumnEmail,
	TeamsUpdateColumnHidden,
	TeamsUpdateColumnID,
	TeamsUpdateColumnName,
	TeamsUpdateColumnOauthID,
	TeamsUpdateColumnPassword,
	TeamsUpdateColumnSecret,
	TeamsUpdateColumnWebsite,
}

func (e TeamsUpdateColumn) IsValid() bool {
	switch e {
	case TeamsUpdateColumnAffiliation, TeamsUpdateColumnBanned, TeamsUpdateColumnBracket, TeamsUpdateColumnCaptainID, TeamsUpdateColumnCountry, TeamsUpdateColumnCreated, TeamsUpdateColumnEmail, TeamsUpdateColumnHidden, TeamsUpdateColumnID, TeamsUpdateColumnName, TeamsUpdateColumnOauthID, TeamsUpdateColumnPassword, TeamsUpdateColumnSecret, TeamsUpdateColumnWebsite:
		return true
	}
	return false
}

func (e TeamsUpdateColumn) String() string {
	return string(e)
}

func (e *TeamsUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid teams_update_column", str)
	}
	return nil
}

func (e TeamsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "tokens"
type TokensConstraint string

const (
	// unique or primary key constraint
	TokensConstraintTokensPkey TokensConstraint = "tokens_pkey"
	// unique or primary key constraint
	TokensConstraintTokensValueKey TokensConstraint = "tokens_value_key"
)

var AllTokensConstraint = []TokensConstraint{
	TokensConstraintTokensPkey,
	TokensConstraintTokensValueKey,
}

func (e TokensConstraint) IsValid() bool {
	switch e {
	case TokensConstraintTokensPkey, TokensConstraintTokensValueKey:
		return true
	}
	return false
}

func (e TokensConstraint) String() string {
	return string(e)
}

func (e *TokensConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokensConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tokens_constraint", str)
	}
	return nil
}

func (e TokensConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "tokens"
type TokensSelectColumn string

const (
	// column name
	TokensSelectColumnCreated TokensSelectColumn = "created"
	// column name
	TokensSelectColumnExpiration TokensSelectColumn = "expiration"
	// column name
	TokensSelectColumnID TokensSelectColumn = "id"
	// column name
	TokensSelectColumnType TokensSelectColumn = "type"
	// column name
	TokensSelectColumnUserID TokensSelectColumn = "user_id"
	// column name
	TokensSelectColumnValue TokensSelectColumn = "value"
)

var AllTokensSelectColumn = []TokensSelectColumn{
	TokensSelectColumnCreated,
	TokensSelectColumnExpiration,
	TokensSelectColumnID,
	TokensSelectColumnType,
	TokensSelectColumnUserID,
	TokensSelectColumnValue,
}

func (e TokensSelectColumn) IsValid() bool {
	switch e {
	case TokensSelectColumnCreated, TokensSelectColumnExpiration, TokensSelectColumnID, TokensSelectColumnType, TokensSelectColumnUserID, TokensSelectColumnValue:
		return true
	}
	return false
}

func (e TokensSelectColumn) String() string {
	return string(e)
}

func (e *TokensSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokensSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tokens_select_column", str)
	}
	return nil
}

func (e TokensSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "tokens"
type TokensUpdateColumn string

const (
	// column name
	TokensUpdateColumnCreated TokensUpdateColumn = "created"
	// column name
	TokensUpdateColumnExpiration TokensUpdateColumn = "expiration"
	// column name
	TokensUpdateColumnID TokensUpdateColumn = "id"
	// column name
	TokensUpdateColumnType TokensUpdateColumn = "type"
	// column name
	TokensUpdateColumnUserID TokensUpdateColumn = "user_id"
	// column name
	TokensUpdateColumnValue TokensUpdateColumn = "value"
)

var AllTokensUpdateColumn = []TokensUpdateColumn{
	TokensUpdateColumnCreated,
	TokensUpdateColumnExpiration,
	TokensUpdateColumnID,
	TokensUpdateColumnType,
	TokensUpdateColumnUserID,
	TokensUpdateColumnValue,
}

func (e TokensUpdateColumn) IsValid() bool {
	switch e {
	case TokensUpdateColumnCreated, TokensUpdateColumnExpiration, TokensUpdateColumnID, TokensUpdateColumnType, TokensUpdateColumnUserID, TokensUpdateColumnValue:
		return true
	}
	return false
}

func (e TokensUpdateColumn) String() string {
	return string(e)
}

func (e *TokensUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokensUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tokens_update_column", str)
	}
	return nil
}

func (e TokensUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "tracking"
type TrackingConstraint string

const (
	// unique or primary key constraint
	TrackingConstraintTrackingPkey TrackingConstraint = "tracking_pkey"
)

var AllTrackingConstraint = []TrackingConstraint{
	TrackingConstraintTrackingPkey,
}

func (e TrackingConstraint) IsValid() bool {
	switch e {
	case TrackingConstraintTrackingPkey:
		return true
	}
	return false
}

func (e TrackingConstraint) String() string {
	return string(e)
}

func (e *TrackingConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackingConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tracking_constraint", str)
	}
	return nil
}

func (e TrackingConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "tracking"
type TrackingSelectColumn string

const (
	// column name
	TrackingSelectColumnDate TrackingSelectColumn = "date"
	// column name
	TrackingSelectColumnID TrackingSelectColumn = "id"
	// column name
	TrackingSelectColumnIP TrackingSelectColumn = "ip"
	// column name
	TrackingSelectColumnType TrackingSelectColumn = "type"
	// column name
	TrackingSelectColumnUserID TrackingSelectColumn = "user_id"
)

var AllTrackingSelectColumn = []TrackingSelectColumn{
	TrackingSelectColumnDate,
	TrackingSelectColumnID,
	TrackingSelectColumnIP,
	TrackingSelectColumnType,
	TrackingSelectColumnUserID,
}

func (e TrackingSelectColumn) IsValid() bool {
	switch e {
	case TrackingSelectColumnDate, TrackingSelectColumnID, TrackingSelectColumnIP, TrackingSelectColumnType, TrackingSelectColumnUserID:
		return true
	}
	return false
}

func (e TrackingSelectColumn) String() string {
	return string(e)
}

func (e *TrackingSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackingSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tracking_select_column", str)
	}
	return nil
}

func (e TrackingSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "tracking"
type TrackingUpdateColumn string

const (
	// column name
	TrackingUpdateColumnDate TrackingUpdateColumn = "date"
	// column name
	TrackingUpdateColumnID TrackingUpdateColumn = "id"
	// column name
	TrackingUpdateColumnIP TrackingUpdateColumn = "ip"
	// column name
	TrackingUpdateColumnType TrackingUpdateColumn = "type"
	// column name
	TrackingUpdateColumnUserID TrackingUpdateColumn = "user_id"
)

var AllTrackingUpdateColumn = []TrackingUpdateColumn{
	TrackingUpdateColumnDate,
	TrackingUpdateColumnID,
	TrackingUpdateColumnIP,
	TrackingUpdateColumnType,
	TrackingUpdateColumnUserID,
}

func (e TrackingUpdateColumn) IsValid() bool {
	switch e {
	case TrackingUpdateColumnDate, TrackingUpdateColumnID, TrackingUpdateColumnIP, TrackingUpdateColumnType, TrackingUpdateColumnUserID:
		return true
	}
	return false
}

func (e TrackingUpdateColumn) String() string {
	return string(e)
}

func (e *TrackingUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackingUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid tracking_update_column", str)
	}
	return nil
}

func (e TrackingUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "unlocks"
type UnlocksConstraint string

const (
	// unique or primary key constraint
	UnlocksConstraintUnlocksPkey UnlocksConstraint = "unlocks_pkey"
)

var AllUnlocksConstraint = []UnlocksConstraint{
	UnlocksConstraintUnlocksPkey,
}

func (e UnlocksConstraint) IsValid() bool {
	switch e {
	case UnlocksConstraintUnlocksPkey:
		return true
	}
	return false
}

func (e UnlocksConstraint) String() string {
	return string(e)
}

func (e *UnlocksConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnlocksConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid unlocks_constraint", str)
	}
	return nil
}

func (e UnlocksConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "unlocks"
type UnlocksSelectColumn string

const (
	// column name
	UnlocksSelectColumnDate UnlocksSelectColumn = "date"
	// column name
	UnlocksSelectColumnID UnlocksSelectColumn = "id"
	// column name
	UnlocksSelectColumnTarget UnlocksSelectColumn = "target"
	// column name
	UnlocksSelectColumnTeamID UnlocksSelectColumn = "team_id"
	// column name
	UnlocksSelectColumnType UnlocksSelectColumn = "type"
	// column name
	UnlocksSelectColumnUserID UnlocksSelectColumn = "user_id"
)

var AllUnlocksSelectColumn = []UnlocksSelectColumn{
	UnlocksSelectColumnDate,
	UnlocksSelectColumnID,
	UnlocksSelectColumnTarget,
	UnlocksSelectColumnTeamID,
	UnlocksSelectColumnType,
	UnlocksSelectColumnUserID,
}

func (e UnlocksSelectColumn) IsValid() bool {
	switch e {
	case UnlocksSelectColumnDate, UnlocksSelectColumnID, UnlocksSelectColumnTarget, UnlocksSelectColumnTeamID, UnlocksSelectColumnType, UnlocksSelectColumnUserID:
		return true
	}
	return false
}

func (e UnlocksSelectColumn) String() string {
	return string(e)
}

func (e *UnlocksSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnlocksSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid unlocks_select_column", str)
	}
	return nil
}

func (e UnlocksSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "unlocks"
type UnlocksUpdateColumn string

const (
	// column name
	UnlocksUpdateColumnDate UnlocksUpdateColumn = "date"
	// column name
	UnlocksUpdateColumnID UnlocksUpdateColumn = "id"
	// column name
	UnlocksUpdateColumnTarget UnlocksUpdateColumn = "target"
	// column name
	UnlocksUpdateColumnTeamID UnlocksUpdateColumn = "team_id"
	// column name
	UnlocksUpdateColumnType UnlocksUpdateColumn = "type"
	// column name
	UnlocksUpdateColumnUserID UnlocksUpdateColumn = "user_id"
)

var AllUnlocksUpdateColumn = []UnlocksUpdateColumn{
	UnlocksUpdateColumnDate,
	UnlocksUpdateColumnID,
	UnlocksUpdateColumnTarget,
	UnlocksUpdateColumnTeamID,
	UnlocksUpdateColumnType,
	UnlocksUpdateColumnUserID,
}

func (e UnlocksUpdateColumn) IsValid() bool {
	switch e {
	case UnlocksUpdateColumnDate, UnlocksUpdateColumnID, UnlocksUpdateColumnTarget, UnlocksUpdateColumnTeamID, UnlocksUpdateColumnType, UnlocksUpdateColumnUserID:
		return true
	}
	return false
}

func (e UnlocksUpdateColumn) String() string {
	return string(e)
}

func (e *UnlocksUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnlocksUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid unlocks_update_column", str)
	}
	return nil
}

func (e UnlocksUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "users"
type UsersConstraint string

const (
	// unique or primary key constraint
	UsersConstraintUsersEmailKey UsersConstraint = "users_email_key"
	// unique or primary key constraint
	UsersConstraintUsersIDOauthIDKey UsersConstraint = "users_id_oauth_id_key"
	// unique or primary key constraint
	UsersConstraintUsersOauthIDKey UsersConstraint = "users_oauth_id_key"
	// unique or primary key constraint
	UsersConstraintUsersPkey UsersConstraint = "users_pkey"
)

var AllUsersConstraint = []UsersConstraint{
	UsersConstraintUsersEmailKey,
	UsersConstraintUsersIDOauthIDKey,
	UsersConstraintUsersOauthIDKey,
	UsersConstraintUsersPkey,
}

func (e UsersConstraint) IsValid() bool {
	switch e {
	case UsersConstraintUsersEmailKey, UsersConstraintUsersIDOauthIDKey, UsersConstraintUsersOauthIDKey, UsersConstraintUsersPkey:
		return true
	}
	return false
}

func (e UsersConstraint) String() string {
	return string(e)
}

func (e *UsersConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_constraint", str)
	}
	return nil
}

func (e UsersConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "users"
type UsersSelectColumn string

const (
	// column name
	UsersSelectColumnAffiliation UsersSelectColumn = "affiliation"
	// column name
	UsersSelectColumnBanned UsersSelectColumn = "banned"
	// column name
	UsersSelectColumnBracket UsersSelectColumn = "bracket"
	// column name
	UsersSelectColumnCountry UsersSelectColumn = "country"
	// column name
	UsersSelectColumnCreated UsersSelectColumn = "created"
	// column name
	UsersSelectColumnEmail UsersSelectColumn = "email"
	// column name
	UsersSelectColumnHidden UsersSelectColumn = "hidden"
	// column name
	UsersSelectColumnID UsersSelectColumn = "id"
	// column name
	UsersSelectColumnName UsersSelectColumn = "name"
	// column name
	UsersSelectColumnOauthID UsersSelectColumn = "oauth_id"
	// column name
	UsersSelectColumnPassword UsersSelectColumn = "password"
	// column name
	UsersSelectColumnSecret UsersSelectColumn = "secret"
	// column name
	UsersSelectColumnTeamID UsersSelectColumn = "team_id"
	// column name
	UsersSelectColumnType UsersSelectColumn = "type"
	// column name
	UsersSelectColumnVerified UsersSelectColumn = "verified"
	// column name
	UsersSelectColumnWebsite UsersSelectColumn = "website"
)

var AllUsersSelectColumn = []UsersSelectColumn{
	UsersSelectColumnAffiliation,
	UsersSelectColumnBanned,
	UsersSelectColumnBracket,
	UsersSelectColumnCountry,
	UsersSelectColumnCreated,
	UsersSelectColumnEmail,
	UsersSelectColumnHidden,
	UsersSelectColumnID,
	UsersSelectColumnName,
	UsersSelectColumnOauthID,
	UsersSelectColumnPassword,
	UsersSelectColumnSecret,
	UsersSelectColumnTeamID,
	UsersSelectColumnType,
	UsersSelectColumnVerified,
	UsersSelectColumnWebsite,
}

func (e UsersSelectColumn) IsValid() bool {
	switch e {
	case UsersSelectColumnAffiliation, UsersSelectColumnBanned, UsersSelectColumnBracket, UsersSelectColumnCountry, UsersSelectColumnCreated, UsersSelectColumnEmail, UsersSelectColumnHidden, UsersSelectColumnID, UsersSelectColumnName, UsersSelectColumnOauthID, UsersSelectColumnPassword, UsersSelectColumnSecret, UsersSelectColumnTeamID, UsersSelectColumnType, UsersSelectColumnVerified, UsersSelectColumnWebsite:
		return true
	}
	return false
}

func (e UsersSelectColumn) String() string {
	return string(e)
}

func (e *UsersSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_select_column", str)
	}
	return nil
}

func (e UsersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "users"
type UsersUpdateColumn string

const (
	// column name
	UsersUpdateColumnAffiliation UsersUpdateColumn = "affiliation"
	// column name
	UsersUpdateColumnBanned UsersUpdateColumn = "banned"
	// column name
	UsersUpdateColumnBracket UsersUpdateColumn = "bracket"
	// column name
	UsersUpdateColumnCountry UsersUpdateColumn = "country"
	// column name
	UsersUpdateColumnCreated UsersUpdateColumn = "created"
	// column name
	UsersUpdateColumnEmail UsersUpdateColumn = "email"
	// column name
	UsersUpdateColumnHidden UsersUpdateColumn = "hidden"
	// column name
	UsersUpdateColumnID UsersUpdateColumn = "id"
	// column name
	UsersUpdateColumnName UsersUpdateColumn = "name"
	// column name
	UsersUpdateColumnOauthID UsersUpdateColumn = "oauth_id"
	// column name
	UsersUpdateColumnPassword UsersUpdateColumn = "password"
	// column name
	UsersUpdateColumnSecret UsersUpdateColumn = "secret"
	// column name
	UsersUpdateColumnTeamID UsersUpdateColumn = "team_id"
	// column name
	UsersUpdateColumnType UsersUpdateColumn = "type"
	// column name
	UsersUpdateColumnVerified UsersUpdateColumn = "verified"
	// column name
	UsersUpdateColumnWebsite UsersUpdateColumn = "website"
)

var AllUsersUpdateColumn = []UsersUpdateColumn{
	UsersUpdateColumnAffiliation,
	UsersUpdateColumnBanned,
	UsersUpdateColumnBracket,
	UsersUpdateColumnCountry,
	UsersUpdateColumnCreated,
	UsersUpdateColumnEmail,
	UsersUpdateColumnHidden,
	UsersUpdateColumnID,
	UsersUpdateColumnName,
	UsersUpdateColumnOauthID,
	UsersUpdateColumnPassword,
	UsersUpdateColumnSecret,
	UsersUpdateColumnTeamID,
	UsersUpdateColumnType,
	UsersUpdateColumnVerified,
	UsersUpdateColumnWebsite,
}

func (e UsersUpdateColumn) IsValid() bool {
	switch e {
	case UsersUpdateColumnAffiliation, UsersUpdateColumnBanned, UsersUpdateColumnBracket, UsersUpdateColumnCountry, UsersUpdateColumnCreated, UsersUpdateColumnEmail, UsersUpdateColumnHidden, UsersUpdateColumnID, UsersUpdateColumnName, UsersUpdateColumnOauthID, UsersUpdateColumnPassword, UsersUpdateColumnSecret, UsersUpdateColumnTeamID, UsersUpdateColumnType, UsersUpdateColumnVerified, UsersUpdateColumnWebsite:
		return true
	}
	return false
}

func (e UsersUpdateColumn) String() string {
	return string(e)
}

func (e *UsersUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_update_column", str)
	}
	return nil
}

func (e UsersUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
